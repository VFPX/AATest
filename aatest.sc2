*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="aatest.scx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
#INCLUDE "aatest.h"

DEFINE CLASS dataenvironment AS dataenvironment 
 	*< CLASSDATA: Baseclass="dataenvironment" Timestamp="" Scale="" Uniqueid="" ClassIcon="2" />

	DataSource = .NULL.
	Height = 200
	Left = 1
	Name = "Dataenvironment"
	Top = 220
	Width = 520

ENDDEFINE

DEFINE CLASS frstestharn AS formset 
 	*< CLASSDATA: Baseclass="formset" Timestamp="" Scale="" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="frmMain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.Column1.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.Column1.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.colPostScript.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.colEventLog.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.grdscript.colEventLog.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page1.cmdDeleteScript" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Shape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.opgdelay" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.spndelay" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.opgfailoption" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.chkoverwritescript" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.chkStartupWin" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.spnRunCount" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label4" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.chkNewVFP" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.chkobjectlevel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.chkVFPError" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label6" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page2.Label5" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.colScriptId.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.colScriptId.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column4.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column5.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column5.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column7.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column7.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column8.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column8.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column10.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column10.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column6.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.Column6.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.colTestId.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.grdtestlog.colTestId.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page3.cmdDeleteTestLog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.Shape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.cmdviewcovlog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.cmdCovprofiler" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.chkcovelogon" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.chkoverwritecovlog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.pgfmain.Page4.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.edtStatus" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="frmMain.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdrecord" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdplay" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.chkPause" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdstop" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.Separator2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdOpenLog" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdinsscript" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.Separator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdVFP" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdexit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tbrTest.cmdhelp" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: abort		&& Exit out of the application
		*m: calcmouseposn		&& Calculate new mouse position
		*m: checktheobj		&& Check for a particular object name from the top level object
		*m: cstate_assign
		*m: deletescripts		&& Method to delete the selected scripts.
		*m: deletetestlog		&& Method to delete the selected test log.
		*m: doclick
		*m: dotheevent
		*m: getcontainerform		&& Returns the container form of the passed name
		*m: geteventvalue		&& Method to get the Event Value based on directive and event.
		*m: getobjwithname
		*m: getobjwithrole
		*m: gettestinfo		&& Accepts the record details like test log
		*m: hex2val
		*m: keybrd
		*m: launchhelp		&& Invoke the help
		*m: launchvfp		&& Launch VFP
		*m: logerror		&& Logs the error messages
		*m: opentable
		*m: play		&& Play the selected script
		*m: playbegin		&& play begining hook
		*m: playend		&& play end hook
		*m: playloop
		*m: playresume		&& Method to resume play from where it had been stopped before.
		*m: playstop		&& Method to handle play getting stopped.
		*m: playtest		&& Play a test script
		*m: record		&& Record script
		*m: recordbegin		&& Record begining hook
		*m: recordend		&& Record end hook
		*m: recordinsscript		&& Insert the recording
		*m: recordpause		&& Pause the recording
		*m: recordstop		&& Stop recording and save the script
		*m: scriptparse		&& Parse the event log script
		*m: sendmouse
		*m: str2guid
		*m: str2num
		*m: vieweventlog		&& Veiw event log
		*p: ccoverlogfile		&& Coverage log file
		*p: ccurrformname		&& Current form name in which the script is being run (it will be form.name or caption if name is not available)
		*p: ccurrwinname		&& Current window/caption (returned by windows for win dialogs or form.caption)
		*p: ceventlogfile		&& The event log file name
		*p: cfoxerror		&& The Fox error message (MESSAGE())
		*p: cguid		&& IAccessible GUId
		*p: clastevent
		*p: cmessagebeforestart		&& MESSAGE() value before start testing
		*p: cresourcefile		&& Resource file name, to restore back
		*p: cscreencaption
		*p: csetescape
		*p: cstate		&& Current state of the form
		*p: cstateprev		&& Previous state
		*p: ctestcaption		&& Test startup window caption
		*p: ctestname		&& Test Description
		*p: lerror		&& Testing error
		*p: lmenuclicked
		*p: lplayinsert		&& Property to flag whether we are inserting a script at a paused point.
		*p: lplaypaused		&& Property to check if play has been paused.
		*p: lsuspend		&& Suspend by pressing hotkey
		*p: nappleft
		*p: napptop
		*p: ncachesize
		*p: ndelay
		*p: nduration		&& Testing time
		*p: nfrmheight
		*p: nfrmleft
		*p: nfrmtop
		*p: nfrmwidth
		*p: nhistcnt
		*p: nlastmousex		&& Last X co-ord of mouse
		*p: nlastmousey		&& Last Y co-ord of mouse
		*p: nmemoryusage		&& Memory usage
		*p: nplayinsertline		&& Property to hold line after which the insertion for recording needs to be done
		*p: nplayinsertscriptrecno		&& Property to hold which record in the script table we are inserting into.
		*p: nplaypausedline		&& Property to hold the line in the script where the play was paused.
		*p: nplaypausedrun		&& Property to hold the run where the script was paused.
		*p: nplaypausedscriptrecno		&& Property to hold which record in the script table the play was paused.
		*p: nruncount
		*p: nscreenleft
		*p: nscreentop
		*p: ntestapphwnd		&& The HWnd of testing application
		*p: ntestid
		*p: ntestrun		&& Test run number
		*p: oglobal		&& Global object which has common functions
		*p: otoolbar
		*p: ovfp		&& The AA client VFP object reference
		*p: trectime		&& Record start date time
		*a: ahist[1,1]
		*a: asplkeys[1,2]
	*</DefinedPropArrayMethod>

	AutoRelease = .T.
	ccurrformname = 		&& Current form name in which the script is being run (it will be form.name or caption if name is not available)
	ccurrwinname = 		&& Current window/caption (returned by windows for win dialogs or form.caption)
	ceventlogfile = 		&& The event log file name
	cfoxerror = 		&& The Fox error message (MESSAGE())
	cguid = 		&& IAccessible GUId
	clastevent = 
	cstate = 0		&& Current state of the form
	cstateprev = 0		&& Previous state
	ctestcaption = 		&& Test startup window caption
	ctestname = 		&& Test Description
	DataSession = 2
	lerror = .F.		&& Testing error
	lmenuclicked = .F.
	lplayinsert = .F.		&& Property to flag whether we are inserting a script at a paused point.
	lplaypaused = .F.		&& Property to check if play has been paused.
	lsuspend = .F.		&& Suspend by pressing hotkey
	Name = "frstestharn"
	nappleft = 0
	napptop = 0
	ncachesize = 20
	ndelay = 0
	nduration = 0		&& Testing time
	nfrmheight = 0
	nfrmleft = 0
	nfrmtop = 0
	nfrmwidth = 0
	nhistcnt = 0
	nlastmousex = 0		&& Last X co-ord of mouse
	nlastmousey = 0		&& Last Y co-ord of mouse
	nmemoryusage = 0		&& Memory usage
	nplayinsertline = 0		&& Property to hold line after which the insertion for recording needs to be done
	nplayinsertscriptrecno = 0		&& Property to hold which record in the script table we are inserting into.
	nplaypausedline = 0		&& Property to hold the line in the script where the play was paused.
	nplaypausedrun = 0		&& Property to hold the run where the script was paused.
	nplaypausedscriptrecno = 0		&& Property to hold which record in the script table the play was paused.
	nruncount = 1
	nscreenleft = 0
	nscreentop = 0
	ntestapphwnd = 0		&& The HWnd of testing application
	ntestid = 0
	ntestrun = 1		&& Test run number
	oglobal = 		&& Global object which has common functions
	otoolbar = 
	ovfp = 		&& The AA client VFP object reference
	trectime = 		&& Record start date time

	ADD OBJECT 'frmMain' AS form WITH ;
		BorderStyle = 1, ;
		Caption = "VFP AA Test Harness", ;
		DoCreate = .T., ;
		Height = 340, ;
		Left = 21, ;
		MaxButton = .F., ;
		Name = "frmMain", ;
		Top = 105, ;
		Width = 601, ;
		WindowState = 0
		*< END OBJECT: BaseClass="form" />

	ADD OBJECT 'frmMain.edtStatus' AS editbox WITH ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 50, ;
		IntegralHeight = .T., ;
		Left = 10, ;
		Name = "edtStatus", ;
		ReadOnly = .T., ;
		TabIndex = 2, ;
		Top = 279, ;
		Width = 582
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'frmMain.Label1' AS label WITH ;
		Caption = "Status :", ;
		FontName = "Tahoma", ;
		Height = 15, ;
		Left = 12, ;
		Name = "Label1", ;
		TabIndex = 3, ;
		Top = 264, ;
		Width = 40
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain' AS pageframe WITH ;
		ErasePage = .T., ;
		Height = 249, ;
		Left = 10, ;
		Name = "pgfmain", ;
		PageCount = 4, ;
		TabIndex = 1, ;
		Top = 8, ;
		Width = 582, ;
		Page1.Caption = "\<Scripts", ;
		Page1.FontName = "Tahoma", ;
		Page1.Name = "Page1", ;
		Page2.Caption = "\<Options", ;
		Page2.FontName = "Tahoma", ;
		Page2.Name = "Page2", ;
		Page3.Caption = "\<Test Log", ;
		Page3.FontName = "Tahoma", ;
		Page3.Name = "Page3", ;
		Page4.Caption = "\<Coverage Log", ;
		Page4.FontName = "Tahoma", ;
		Page4.Name = "Page4"
		*< END OBJECT: BaseClass="pageframe" />

	ADD OBJECT 'frmMain.pgfmain.Page1.cmdDeleteScript' AS commandbutton WITH ;
		Caption = "\<Delete", ;
		FontName = "Tahoma", ;
		Height = 27, ;
		Left = 481, ;
		Name = "cmdDeleteScript", ;
		TabIndex = 2, ;
		Top = 182, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript' AS grid WITH ;
		ColumnCount = 9, ;
		DeleteMark = .F., ;
		FontName = "Tahoma", ;
		GridLineColor = 192,192,192, ;
		Height = 160, ;
		Highlight = .F., ;
		Left = 12, ;
		Name = "grdscript", ;
		Panel = 1, ;
		RecordSource = "aascripts", ;
		TabIndex = 1, ;
		Top = 12, ;
		Width = 552, ;
		Column1.ControlSource = "aascripts.selected", ;
		Column1.CurrentControl = "Check1", ;
		Column1.FontName = "Tahoma", ;
		Column1.Name = "Column1", ;
		Column1.Sparse = .F., ;
		Column1.Width = 41, ;
		Column2.ControlSource = "aascripts.id", ;
		Column2.FontName = "Tahoma", ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 53, ;
		Column3.ControlSource = "aascripts.desc", ;
		Column3.FontName = "Tahoma", ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 138, ;
		Column4.ControlSource = "aascripts.caption", ;
		Column4.FontName = "Tahoma", ;
		Column4.Name = "Column4", ;
		Column4.ReadOnly = .T., ;
		Column4.Width = 149, ;
		Column5.ControlSource = "aascripts.rectime", ;
		Column5.FontName = "Tahoma", ;
		Column5.Name = "Column5", ;
		Column5.ReadOnly = .T., ;
		Column5.Width = 80, ;
		Column6.ControlSource = "aascripts.prescript", ;
		Column6.FontName = "Tahoma", ;
		Column6.Name = "colPreScript", ;
		Column6.ReadOnly = .T., ;
		Column6.Width = 60, ;
		Column7.ControlSource = "aaScripts.Script", ;
		Column7.FontName = "Tahoma", ;
		Column7.Name = "colScript", ;
		Column7.ReadOnly = .T., ;
		Column8.ControlSource = "aaScripts.PostScript", ;
		Column8.FontName = "Tahoma", ;
		Column8.Name = "colPostScript", ;
		Column8.ReadOnly = .T., ;
		Column9.ControlSource = "aaScripts.EvtLog", ;
		Column9.FontName = "Tahoma", ;
		Column9.Name = "colEventLog", ;
		Column9.ReadOnly = .T.
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.colEventLog.Header1' AS header WITH ;
		Caption = "Event Log", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.colEventLog.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.colPostScript.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.Column1.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		FontName = "Tahoma", ;
		Name = "Check1", ;
		Visible = .T.
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.Column1.Header1' AS header WITH ;
		Caption = "Select", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.Column1.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.Column2.Header1' AS header WITH ;
		Caption = "Script ID", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page1.grdscript.Column2.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.chkNewVFP' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Always \<launch new VFP window *", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 20, ;
		Name = "chkNewVFP", ;
		TabIndex = 3, ;
		Top = 48, ;
		Value = .T., ;
		Width = 206
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.chkobjectlevel' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "C\<heck for presence of each object", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 241, ;
		Name = "chkobjectlevel", ;
		TabIndex = 6, ;
		ToolTipText = "Check the presence of all the objects", ;
		Top = 48, ;
		Value = .F., ;
		Width = 209
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.chkoverwritescript' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Overwrite e\<xisting script", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 20, ;
		Name = "chkoverwritescript", ;
		TabIndex = 2, ;
		Top = 26, ;
		Value = .F., ;
		Width = 151
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.chkStartupWin' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Validate startup window before playback", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 241, ;
		Name = "chkStartupWin", ;
		TabIndex = 5, ;
		ToolTipText = "Check the startup window/screen caption", ;
		Top = 26, ;
		Value = .F., ;
		Width = 242
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.chkVFPError' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Check for program \<error", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 241, ;
		Name = "chkVFPError", ;
		TabIndex = 7, ;
		ToolTipText = "Check for the program error (VFP)", ;
		Top = 70, ;
		Value = .F., ;
		Width = 150
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label1' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Recording", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 22, ;
		Name = "Label1", ;
		Style = 3, ;
		TabIndex = 1, ;
		Top = 6, ;
		Width = 56
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label2' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Playback", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 241, ;
		Name = "Label2", ;
		Style = 3, ;
		TabIndex = 4, ;
		Top = 6, ;
		Width = 48
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label3' AS label WITH ;
		AutoSize = .T., ;
		Caption = "On script failure", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 417, ;
		Name = "Label3", ;
		Style = 3, ;
		TabIndex = 13, ;
		Top = 98, ;
		Width = 87
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label4' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<Run count:", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 433, ;
		Name = "Label4", ;
		TabIndex = 8, ;
		Top = 71, ;
		Width = 63
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label5' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "* Needed for Windows XP and above", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 16, ;
		Name = "Label5", ;
		TabIndex = 10, ;
		Top = 185, ;
		Width = 206, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Label6' AS label WITH ;
		AutoSize = .T., ;
		Caption = "Delay between events", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 249, ;
		Name = "Label6", ;
		Style = 3, ;
		TabIndex = 10, ;
		Top = 98, ;
		Width = 126
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page2.opgdelay' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 1, ;
		ButtonCount = 2, ;
		ControlSource = "", ;
		Height = 84, ;
		Left = 241, ;
		Name = "opgdelay", ;
		TabIndex = 11, ;
		Top = 106, ;
		Value = 1, ;
		Width = 156, ;
		Option1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "\<Use recorded time", ;
		Option1.ControlSource = "", ;
		Option1.FontName = "Tahoma", ;
		Option1.Height = 16, ;
		Option1.Left = 8, ;
		Option1.Name = "Option1", ;
		Option1.Top = 10, ;
		Option1.Value = 1, ;
		Option1.Width = 120, ;
		Option2.AutoSize = .T., ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "Ti\<me interval (ms):", ;
		Option2.ControlSource = "", ;
		Option2.FontName = "Tahoma", ;
		Option2.Height = 16, ;
		Option2.Left = 8, ;
		Option2.Name = "Option2", ;
		Option2.Top = 30, ;
		Option2.Value = 0, ;
		Option2.Width = 122
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'frmMain.pgfmain.Page2.opgfailoption' AS optiongroup WITH ;
		BackStyle = 0, ;
		ButtonCount = 3, ;
		ControlSource = "", ;
		Height = 84, ;
		Left = 409, ;
		Name = "opgfailoption", ;
		TabIndex = 14, ;
		Top = 106, ;
		Width = 144, ;
		Option1.AutoSize = .T., ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "A\<bort playback", ;
		Option1.ControlSource = "", ;
		Option1.FontName = "Tahoma", ;
		Option1.Height = 16, ;
		Option1.Left = 8, ;
		Option1.Name = "Option1", ;
		Option1.Top = 10, ;
		Option1.Value = 1, ;
		Option1.Width = 100, ;
		Option2.AutoSize = .T., ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "S\<kip current event", ;
		Option2.ControlSource = "", ;
		Option2.FontName = "Tahoma", ;
		Option2.Height = 16, ;
		Option2.Left = 8, ;
		Option2.Name = "Option2", ;
		Option2.Top = 30, ;
		Option2.Width = 121, ;
		Option3.AutoSize = .T., ;
		Option3.BackStyle = 0, ;
		Option3.Caption = "Continue pla\<yback", ;
		Option3.ControlSource = "", ;
		Option3.FontName = "Tahoma", ;
		Option3.Height = 16, ;
		Option3.Left = 8, ;
		Option3.Name = "Option3", ;
		Option3.Top = 50, ;
		Option3.Value = 0, ;
		Option3.Width = 118
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Shape1' AS shape WITH ;
		BackStyle = 0, ;
		Height = 194, ;
		Left = 10, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 14, ;
		Width = 226
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'frmMain.pgfmain.Page2.Shape2' AS shape WITH ;
		BackStyle = 0, ;
		Height = 194, ;
		Left = 229, ;
		Name = "Shape2", ;
		SpecialEffect = 0, ;
		Top = 14, ;
		Width = 336
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'frmMain.pgfmain.Page2.spndelay' AS spinner WITH ;
		ControlSource = " Thisformset.nDelay", ;
		Enabled = .F., ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 24, ;
		Increment = 50.00, ;
		KeyboardLowValue = 0, ;
		Left = 331, ;
		Name = "spndelay", ;
		SpinnerLowValue = -1000.00, ;
		TabIndex = 12, ;
		Top = 156, ;
		Width = 54
		*< END OBJECT: BaseClass="spinner" />

	ADD OBJECT 'frmMain.pgfmain.Page2.spnRunCount' AS spinner WITH ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 24, ;
		KeyboardLowValue = 1, ;
		Left = 499, ;
		Name = "spnRunCount", ;
		SpinnerLowValue = 1.00, ;
		TabIndex = 9, ;
		ToolTipText = "Repeat count", ;
		Top = 68, ;
		Width = 54
		*< END OBJECT: BaseClass="spinner" />

	ADD OBJECT 'frmMain.pgfmain.Page3.cmdDeleteTestLog' AS commandbutton WITH ;
		Caption = "\<Delete", ;
		FontName = "Tahoma", ;
		Height = 27, ;
		Left = 481, ;
		Name = "cmdDeleteTestLog", ;
		TabIndex = 2, ;
		Top = 182, ;
		Width = 84
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog' AS grid WITH ;
		ColumnCount = 10, ;
		DeleteMark = .F., ;
		FontName = "Tahoma", ;
		GridLineColor = 192,192,192, ;
		Height = 160, ;
		Highlight = .F., ;
		Left = 12, ;
		Name = "grdtestlog", ;
		Panel = 1, ;
		RecordSource = "aatestlog", ;
		TabIndex = 1, ;
		Top = 12, ;
		Width = 552, ;
		Column1.ColumnOrder = 3, ;
		Column1.ControlSource = "aatestlog.ScriptId", ;
		Column1.FontName = "Tahoma", ;
		Column1.Name = "colScriptId", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 52, ;
		Column10.ColumnOrder = 2, ;
		Column10.ControlSource = "aatestlog.TestId", ;
		Column10.FontName = "Tahoma", ;
		Column10.Name = "colTestId", ;
		Column10.ReadOnly = .T., ;
		Column2.ColumnOrder = 4, ;
		Column2.ControlSource = "aatestlog.iterno", ;
		Column2.FontName = "Tahoma", ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 47, ;
		Column3.ColumnOrder = 5, ;
		Column3.ControlSource = "aatestlog.name", ;
		Column3.FontName = "Tahoma", ;
		Column3.Name = "Column3", ;
		Column3.ReadOnly = .T., ;
		Column3.Width = 144, ;
		Column4.ColumnOrder = 6, ;
		Column4.ControlSource = 'IIF(aatestlog.passed, "Pass", "Fail")', ;
		Column4.FontName = "Tahoma", ;
		Column4.Name = "Column4", ;
		Column4.ReadOnly = .T., ;
		Column4.Width = 61, ;
		Column5.ColumnOrder = 7, ;
		Column5.ControlSource = "aatestlog.results", ;
		Column5.FontName = "Tahoma", ;
		Column5.Name = "Column5", ;
		Column5.ReadOnly = .T., ;
		Column5.Width = 46, ;
		Column6.ColumnOrder = 8, ;
		Column6.ControlSource = "aatestlog.memuse", ;
		Column6.FontName = "Tahoma", ;
		Column6.Name = "Column7", ;
		Column6.ReadOnly = .T., ;
		Column6.Width = 86, ;
		Column7.ColumnOrder = 9, ;
		Column7.ControlSource = "aatestlog.duration", ;
		Column7.FontName = "Tahoma", ;
		Column7.Name = "Column8", ;
		Column7.ReadOnly = .T., ;
		Column7.Width = 75, ;
		Column8.ColumnOrder = 10, ;
		Column8.ControlSource = "aatestlog.playtime", ;
		Column8.FontName = "Tahoma", ;
		Column8.Name = "Column10", ;
		Column8.ReadOnly = .T., ;
		Column8.Width = 88, ;
		Column9.ColumnOrder = 1, ;
		Column9.ControlSource = "aaTestLog.Selected", ;
		Column9.FontName = "Tahoma", ;
		Column9.Name = "Column6", ;
		Column9.Sparse = .F., ;
		Column9.Width = 43
		*< END OBJECT: BaseClass="grid" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.colScriptId.Header1' AS header WITH ;
		Caption = "Script ID", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.colScriptId.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.colTestId.Header1' AS header WITH ;
		Caption = "Test ID", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.colTestId.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column10.Header1' AS header WITH ;
		Caption = "Playtime", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column10.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column2.Header1' AS header WITH ;
		Caption = "Iter #", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column2.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column3.Header1' AS header WITH ;
		Caption = "Description", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column3.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column4.Header1' AS header WITH ;
		Caption = "Pass/Fail", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column4.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column5.Header1' AS header WITH ;
		Caption = "Results", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column5.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column6.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		FontName = "Tahoma", ;
		Height = 17, ;
		Left = 33, ;
		Name = "Check1", ;
		Top = 34, ;
		Width = 60
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column6.Header1' AS header WITH ;
		Caption = "Select", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column7.Header1' AS header WITH ;
		Caption = "Memory Usage", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column7.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column8.Header1' AS header WITH ;
		Caption = "Duration", ;
		FontName = "Tahoma", ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'frmMain.pgfmain.Page3.grdtestlog.Column8.Text1' AS textbox WITH ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'frmMain.pgfmain.Page4.chkcovelogon' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Turn on coverage \<logging during playback", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 25, ;
		Name = "chkcovelogon", ;
		TabIndex = 1, ;
		Top = 26, ;
		Value = .F., ;
		Width = 248
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page4.chkoverwritecovlog' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Overwrite the log if \<file exists", ;
		ControlSource = "", ;
		FontName = "Tahoma", ;
		Height = 16, ;
		Left = 25, ;
		Name = "chkoverwritecovlog", ;
		TabIndex = 2, ;
		Top = 50, ;
		Value = .F., ;
		Width = 179
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'frmMain.pgfmain.Page4.cmdCovprofiler' AS commandbutton WITH ;
		Caption = "Coverage \<Profiler", ;
		FontName = "Tahoma", ;
		Height = 27, ;
		Left = 445, ;
		Name = "cmdCovprofiler", ;
		TabIndex = 4, ;
		Top = 62, ;
		Width = 106
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'frmMain.pgfmain.Page4.cmdviewcovlog' AS commandbutton WITH ;
		Caption = "\<View Log", ;
		FontName = "Tahoma", ;
		Height = 27, ;
		Left = 445, ;
		Name = "cmdviewcovlog", ;
		TabIndex = 3, ;
		Top = 26, ;
		Width = 106
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'frmMain.pgfmain.Page4.Label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Note: The coverage log is created when playing back the script. The coverage time also includes the playback overhead.", ;
		FontName = "Tahoma", ;
		Height = 36, ;
		Left = 25, ;
		Name = "Label1", ;
		TabIndex = 5, ;
		Top = 158, ;
		Width = 528, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'frmMain.pgfmain.Page4.Shape1' AS shape WITH ;
		BackStyle = 0, ;
		Height = 192, ;
		Left = 12, ;
		Name = "Shape1", ;
		SpecialEffect = 0, ;
		Top = 14, ;
		Width = 553
		*< END OBJECT: BaseClass="shape" />

	ADD OBJECT 'tbrTest' AS tbraatest WITH ;
		Caption = "Test Harness", ;
		Height = 36, ;
		Left = 26, ;
		Name = "tbrTest", ;
		Top = 11, ;
		Width = 288
		*< END OBJECT: ClassLib="aautils.vcx" BaseClass="toolbar" />

	ADD OBJECT 'tbrTest.chkPause' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		ControlSource = "", ;
		Height = 30, ;
		Left = 63, ;
		Name = "chkPause", ;
		Picture = pause.bmp, ;
		Style = 1, ;
		TabIndex = 4, ;
		ToolTipText = "Pause/Resume Recording/Playback", ;
		Top = 3, ;
		Value = .F., ;
		Width = 30, ;
		ZOrderSet = 2
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'tbrTest.cmdexit' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 224, ;
		Name = "cmdexit", ;
		Picture = close.bmp, ;
		TabIndex = 10, ;
		ToolTipText = "Exit", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdhelp' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 253, ;
		Name = "cmdhelp", ;
		Picture = help.bmp, ;
		TabIndex = 8, ;
		ToolTipText = "Help/Readme", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 10
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdinsscript' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 158, ;
		Name = "cmdinsscript", ;
		Picture = insert.bmp, ;
		TabIndex = 5, ;
		ToolTipText = "Insert new recording", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdOpenLog' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 129, ;
		Name = "cmdOpenLog", ;
		Picture = open.bmp, ;
		TabIndex = 0, ;
		ToolTipText = "Edit the test script", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdplay' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 34, ;
		Name = "cmdplay", ;
		Picture = play.bmp, ;
		TabIndex = 2, ;
		ToolTipText = "Play the script", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdrecord' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 5, ;
		Name = "cmdrecord", ;
		Picture = record.bmp, ;
		TabIndex = 1, ;
		ToolTipText = "Record the test script", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdstop' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 92, ;
		Name = "cmdstop", ;
		Picture = stop.bmp, ;
		TabIndex = 3, ;
		ToolTipText = "Stop Recording/Playback", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 3
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.cmdVFP' AS commandbutton WITH ;
		Caption = "", ;
		Height = 30, ;
		Left = 195, ;
		Name = "cmdVFP", ;
		Picture = fox.bmp, ;
		TabIndex = 8, ;
		ToolTipText = "Launch new VFP application/window", ;
		Top = 3, ;
		Width = 30, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'tbrTest.Separator1' AS separator WITH ;
		Height = 0, ;
		Left = 195, ;
		Name = "Separator1", ;
		Top = 3, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />

	ADD OBJECT 'tbrTest.Separator2' AS separator WITH ;
		Height = 0, ;
		Left = 129, ;
		Name = "Separator2", ;
		Top = 3, ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />
	
	PROCEDURE abort		&& Exit out of the application
		WITH Thisformset
		*	SET STATUS BAR ON
			.oGlobal = .NULL.
			.oToolBar = .NULL.
			
			nFormCount = THIS.FormCount
		
			FOR I = nFormCount TO 1 STEP -1
				.Forms(i).Release
			ENDFOR
			
			.Release
		ENDWITH
	ENDPROC

	PROCEDURE calcmouseposn		&& Calculate new mouse position
		PARAMETERS oAcc, nMouseX, nMouseY
		
		LOCAL nObjLeft, nObjTop, nObjWidth, nObjHeight
		
		STORE 0 TO nObjLeft, nObjTop, nObjWidth, nObjHeight
		
		oAcc.accLocation(@nObjLeft, @nObjTop, @nObjWidth, @nObjHeight, 0)
		
		*-- If the object has been moved horizontally
		IF NOT BETWEEN(nMouseX, nObjLeft, nObjLeft + nObjWidth)
			nMouseX = nObjLeft + 1  && calculate some arbitrary position within the object
		ENDIF
		
		*-- If the object has been moved vertically
		IF NOT BETWEEN(nMouseY, nObjTop, nObjTop + nObjHeight)
			nMouseY = nObjTop + 1   && calculate some arbitrary position within the object
		ENDIF
		
		RETURN
	ENDPROC

	PROCEDURE checktheobj		&& Check for a particular object name from the top level object
		LPARAMETERS oAccContainer, cEpath, lCheckFocus, oAccObj
		
		LOCAL cTmp, nDotPosn, nCnt, i, lfGetNewOne, cWord, oRet, lReturn, cMessage, nAccState
		
		*-- Object's state (focused, etc..)
		nAccState = 0
		
		lReturn = .t.
		
		cMessage = ""
		
		nCnt = 0
		
		cStart = oAccContainer.AccName(0) + "."
		
		cTmp = m.cEpath + '.'
		
		*-- Truncate the startup object
		cTmp = SUBSTR(m.cTmp, ATC(cStart, cTmp) + LEN(cStart))
		
		oRet = oAccContainer
		
		WITH This
		
			DO WHILE NOT .lError
				nDotPosn = AT('.', m.cTmp)
		
				IF m.nDotPosn = 0
					EXIT
				ENDIF
		
				cWord = LEFT(m.cTmp, m.nDotPosn - 1)
				cTmp = SUBSTR(m.cTmp, m.nDotPosn + 1)
		
				nCnt = nCnt + 1
				lfGetNewOne = .f.
		
				IF nCnt <= .nHistcnt
		
					IF LOWER(cWord) = .ahist[nCnt,1]
						oRet = .ahist[nCnt,2]
					ELSE
						* not following cache... clear rest out
						FOR i = nCnt TO .nCacheSize
							IF ISNULL(.ahist[m.i,1])
								EXIT
							ENDIF
							.ahist[m.i,1]=.null.
							.ahist[m.i,2]=.null.
						ENDFOR
						.nHistcnt = nCnt - 1
						lfGetNewOne = .t.
					ENDIF
		
				ELSE
					lfGetNewOne = .t.
				ENDIF
		
				IF lfGetNewOne
					IF VARTYPE(oRet)#"O"
		*!*	?'blank obj'+cword
		*!*	??CHR(7)
					ELSE
						oRet = .GetObjWithName(oRet, cWord)
		
						.ahist[nCnt,1] = LOWER(cWord)
						.ahist[nCnt,2] = oRet
						.nHistcnt = .nHistcnt + 1
					ENDIF
					
				ENDIF
		
			ENDDO
		
			*-- if the object not exists
			IF ISNULL(oRet)
				lReturn = .f.
				cMessage = MSG_NOOBJECT_LOC + " " + MSG_SCRIPTLINE_LOC + STR(RECNO("events"))
			ELSE
		
				*-- If it needs to check whether the object is focussed (for keypress)
				IF lCheckFocus
		
					nAccState = oRet.accState(0)
		
					*-- If the focus is not in current object
					IF BITAND(nAccState, 2^Cn_State_Focused) <= 0
						lReturn = .f.
						cMessage = MSG_NOFOCUS2_LOC + MSG_SCRIPTLINE_LOC + STR(RECNO("events"))
					ENDIF
		
				ENDIF
		
			ENDIF
		
			*-- Log the error if it fails to check the object
			IF NOT lReturn
		
				*-- Abort playback
				IF .frmMain.pgfmain.Page2.opgfailoption.Value = 1
					.LogError(cMessage, Cc_Error)
				ELSE
					.LogError(cMessage, Cc_Warning)
				ENDIF
		
			ENDIF
		
		ENDWITH
		
		*-- Pass the object by reference
		oAccObj = oRet
		
		RETURN lReturn
		
	ENDPROC

	PROCEDURE cstate_assign
		LPARAMETERS vNewVal
		
		*-- Prev state
		This.cStatePrev = THIS.cState
		
		THIS.cState = m.vNewVal
		
		*-- On changing the state value, the screen objects needs to  be enabled/disabled
		*-- according to the value (check has been done in refresh of each objects)
		Thisformset.Refresh
		
	ENDPROC

	PROCEDURE deletescripts		&& Method to delete the selected scripts.
		LOCAL	lContinue, ;
				lc_TempFile
		
		lContinue = .t.
		
		*-- Set the scripts page as the active page
		ThisFormSet.frmMain.pgfmain.ActivePage = 1
		
		SELECT aaScripts
		
		LOCATE FOR selected
		
		IF NOT FOUND()
			= MESSAGEBOX(MSG_NOSCRIPT_LOC,0 + 48, WINDOWTITLE_LOC)
			lContinue = .f.
		ENDIF
		
		IF lContinue
		
			IF NOT MESSAGEBOX(MSG_DELSCRIPT1_LOC, 4+32+256, WINDOWTITLE_LOC) = 6
				lContinue = .f.
			ENDIF
		
		ENDIF
		
		IF lContinue
		
			*-- Delete all selected scripts
			SCAN FOR selected
				REPLACE selected WITH .f. IN aaScripts
				DELETE IN aaScripts
			ENDSCAN
		
				IF MESSAGEBOX(MSG_DELSCRIPT2_LOC, 4+32+256, WINDOWTITLE_LOC) = 6
					*-- Issuing PACK causes the grid to be made blank. So this workaround.
					lc_TempFile = SYS(2023)+ "\" + SYS(2015) + ".DBF"
					COPY TO (lc_TempFile)
					ZAP
					APPEND FROM (lc_TempFile)
					DELETE FILE (FORCEEXT(lc_TempFile, "*"))
				ENDIF
		
			GOTO TOP IN aaScripts
			This.frmMain.pgfmain.Page1.grdscript.Refresh()
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE deletetestlog		&& Method to delete the selected test log.
		LOCAL	lContinue, ;
				nSno, ;
				lc_TempFile
		
		lContinue = .t.
		
		SELECT aaTestLog
		
		lContinue = .t.
		
		SELECT aaTestLog
		
		LOCATE FOR Selected
		
		IF NOT FOUND()
			= MESSAGEBOX(MSG_NOTESTLOG_LOC,0 + 48, WINDOWTITLE_LOC)
			lContinue = .f.
		ENDIF
		
		IF lContinue
		
			IF NOT MESSAGEBOX(MSG_DELLOG1_LOC, 4+32+256, WINDOWTITLE_LOC) = 6
				lContinue = .f.
			ENDIF
		
		ENDIF
		
		IF lContinue
		
			*-- Delete all selected test logs
			SCAN FOR selected
				REPLACE selected WITH .f. IN aaTestLog
				DELETE IN aaTestlog
			ENDSCAN
		
			IF MESSAGEBOX(MSG_DELLOG2_LOC, 4+32+256, WINDOWTITLE_LOC) = 6
				*-- Issuing PACK causes the grid to be made blank. So this workaround.
				lc_TempFile = SYS(2023)+ "\" + SYS(2015) + ".DBF"
				COPY TO (lc_TempFile)
				ZAP
				APPEND FROM (lc_TempFile)
				DELETE FILE (FORCEEXT(lc_TempFile, "*"))
			ENDIF
		
			GOTO TOP IN aaTestLog
			ThisFormSet.frmMain.pgfmain.Page3.Refresh()
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE Destroy
		LOCAL	cTemp, ;
				cSetPath
		
		cTemp = This.cSetEscape
		
		POP KEY
		
		POP MENU _MSYSMENU
		
		*-- Release the windows if defined otherwise it holds the table opened in the
		*-- private data sessions
		CLEAR WINDOW
		
		*-- This code is required to show the command window if its docked
		lDockEnable = WDOCKABLE('command')
		WDOCKABLE('command', .f.)
		WDOCKABLE('command', lDockEnable)
		
		_Screen.Caption = This.cScreenCaption
		
		SET ESCAPE &cTemp.
		
		IF NOT EMPTY(This.cResourceFile)
			SET RESOURCE TO (This.cResourceFile)
		ENDIF
		
		**  Restore the path
		cSetPath = SET('PATH')
		
		cSetPath = STRTRAN(cSetPath, ',' + TESTHARNESSPATH_LOC)
		cSetPath = STRTRAN(cSetPath, TESTHARNESSPATH_LOC)
		
		SET PATH TO (cSetPath)
		
		*-- Cleare DLL declarations
		CLEAR DLLS	Sleep, ;
					keybd_event, ;
					GetRoleText, ;
					SetForegroundWindow, ;
					SendInput, ;
					FindWindow, ;
					AccessibleObjectFromWindow, ;
					AccessibleChildren, ;
					FindWindowEx, ;
					GetWindow, ;
					GetWindowText, ;
					IsWindowVisible, ;
					GetSystemDirectory
		
		RETURN
		
		
	ENDPROC

	PROCEDURE doclick
		LPARAMETERS cMouseEvent, cMouseEventId, lMouseDownUp,x,y, nShiftCtrlAlt 
		
		DO CASE
		  CASE nShiftCtrlAlt = 1
			*-- Shift down
			KEYBD_EVENT(VK_LSHIFT,0,0,0)
		  CASE nShiftCtrlAlt = 2
			*-- Ctrl down
			KEYBD_EVENT(VK_LCONTROL,0,0,0)
		  CASE nShiftCtrlAlt = 4
		  *-- Alt down - not handled now which brings up help
		ENDCASE
		
		IF INLIST(cMouseEventId, "000000A4", "00000204","000000A5", "00000205") && right mouse
		
			IF lMouseDownUp OR cMouseEvent = "MouseDown"
				THIS.sendmouse(MOUSEEVENTF_ABSOLUTE + MOUSEEVENTF_MOVE + MOUSEEVENTF_RIGHTDOWN, ;
					m.x * 65536 / SYSMETRIC(1), m.y * 65536 / SYSMETRIC(2))
			ENDIF
		
			IF lMouseDownUp OR cMouseEvent = "MouseUp"
				THIS.sendmouse(MOUSEEVENTF_ABSOLUTE + MOUSEEVENTF_MOVE + MOUSEEVENTF_RIGHTUP, ;
					m.x * 65536 / SYSMETRIC(1), m.y * 65536 / SYSMETRIC(2))
			ENDIF
		
		ELSE
		
			IF lMouseDownUp OR cMouseEvent = "MouseDown"
				THIS.sendmouse(MOUSEEVENTF_ABSOLUTE + MOUSEEVENTF_MOVE + MOUSEEVENTF_LEFTDOWN, ;
					m.x * 65536 / SYSMETRIC(1), m.y * 65536 / SYSMETRIC(2))
			ENDIF
		
			IF lMouseDownUp OR cMouseEvent = "MouseUp"
				THIS.sendmouse(MOUSEEVENTF_ABSOLUTE + MOUSEEVENTF_MOVE + MOUSEEVENTF_LEFTUP, ;
					m.x * 65536 / SYSMETRIC(1), m.y * 65536 / SYSMETRIC(2))
			ENDIF
		
		ENDIF
		
		DO CASE
		  CASE nShiftCtrlAlt = 1
			*-- Shift down
			KEYBD_EVENT(VK_LSHIFT,0,KEYEVENTF_KEYUP,0)
		  CASE nShiftCtrlAlt = 2
			*-- Ctrl down
			KEYBD_EVENT(VK_LCONTROL,0,KEYEVENTF_KEYUP,0)
		  CASE nShiftCtrlAlt = 4
		  *-- Alt down - not handled now which brings up help
		ENDCASE
		
		RETURN
	ENDPROC

	PROCEDURE dotheevent
		PARAMETERS oAcc, cEpath , cEvent, nx, ny, lFormTitleBar
		
		LOCAL nXOffset, ;
		      nYOffset, ;
		      lMouseDownUp, ;
		      nMouseX, ;
		      nMouseY, ;
		      nShiftCtrlAlt
		
		STORE 0 TO nXOffset, nYOffset, nMouseX, nMouseY, nShiftCtrlAlt
		
		lMouseDownUp = .t.  && whether to play mouse down/up together
		
		DO CASE
			CASE event="KeyPress"
				*-- VFP keyboard events are mereged with win keypress
		
				*-- Repeat the keystrokes if its multiple at the same time
				FOR nRepeatCount = 1 TO nx
					*-- Pass the value of nChar, nVK
					This.keybrd(val(params), VAL(GETWORDNUM(params,2)))
				ENDFOR
		
			CASE ATC("Mouse", event) # 0
		
				*-- NOTE : The following case structure shouldn't be re-aligned
				DO CASE
					CASE NOT FoxEvt AND ; 
						(INLIST(EventId, "000000A1", "000000A2","000000A4", "000000A5") OR ;
						cEvent="MouseUp" AND val(params) >= 1) 
						
						** &&OR This.lMenuClicked)
		
						*-- Do the following only for non VFP (ie. WINDOWS) events
						*-- If the menu clicked. MouseDown event id will always be 000000A?, where as for mouse up
						*-- val(params) = 1
						
						IF val(params) = 1
							nXOffset = This.oVfp.Left - This.nAppLeft
							nYOffset = This.oVfp.Top - This.nAppTop
						ELSE
						    *-- Click on the main VFP window titlebar (ie. val(params) = 2)
							nXOffset = This.oVfp.Left - This.nAppLeft + This.nScreenLeft
							nYOffset = This.oVfp.Top - This.nAppTop  + This.nScreenTop
							*-- NOTE : The screen co-ordinates change if the toolbar is docked
							*--        If the docking status has been changed during playback which is different from
							*--        the one during recording, then it may cause some problems
							*--        The screen offset may also to be calculated during that time.
						ENDIF
		
						*-- Do the mouse up and down separately
		**				lMouseDownUp = .f.
		
					CASE ATC(This.oVfp.Caption,m.cEpath) # 0	&& coordinates relative to main vfp window
		                *-- MESSAGEBOX() clicks
						nXOffset = This.nAppLeft + 3
						nYOffset = This.nAppTop  + 22*2
		
					CASE NOT lFormTitleBar
						*-- if the form has no title bar, don't add the titlebar offset
						nXOffset = This.nfrmLeft + 3
						nYOffset = This.nfrmTop
					OTHERWISE
						* adjust for window client area (minus titlebar)
						nXOffset = This.nfrmLeft + 3
						nYOffset = This.nfrmTop + 22
				ENDCASE
		
				*-- if mouseup (play both up/down) or separate mouse up/down
				IF  cEvent="MouseUp" OR NOT lMouseDownUp
		
					*-- just play mouse up on the same place if click on window border or close box (Y Co-ord > 65000)
					IF ny > 65000 OR nx > 65000
						nMouseX = This.nLastMouseX
						nMouseY = This.nLastMouseY
					ELSE
						nMouseX = nXOffset + nx
						nMouseY = nYOffset + ny
		
						*-- Check the location of the objects whether it has been moved 
						IF NOT ISNULL(oAcc)
							
							This.CalcMousePosn(oAcc, @nMouseX, @nMouseY)
							
						ENDIF
						
					ENDIF
		
					*-- For VFP events check for Shift, ctrl with mouse
					IF FoxEvt
						nShiftCtrlAlt = VAL(GETWORDNUM(params,2))
					ELSE
						*-- Non fox clicks with shift, ctrl... doesn't have significance
						*-- so its not handled now
						nShiftCtrlAlt = 0
					ENDIF
		
					This.doclick(event, eventid, lMouseDownUp, nMouseX, nMouseY, nShiftCtrlAlt)
		
				ENDIF
		
				This.nLastMouseX = nXOffset + nx
				This.nLastMouseY = nYOffset + ny
		ENDCASE
		
		RETURN
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		WITH This
		
			DO CASE
				CASE .lError
					*-- Don't log/display error if there is already an error
		
				CASE .cState = Cc_StatePlay AND ;
					TYPE("Thisformset.frmMain.BaseClass") = "C"
					*-- If the form is loaded and
					*-- If there is an error while playback, log it
					.LogError(MSG_PROGERROR_LOC + MESSAGE(), Cc_Error)
		
				OTHERWISE
					*-- If there is an error before loading the form itself
					MESSAGEBOX(MSG_PROGERROR_LOC + Cc_EOL + MESSAGE() ;
								+ Cc_EOL + "Method : " + cMethod + ;
								"  Line : " + STR(nLine, 3), ;
								WINDOWTITLE_LOC, 16)
					.lError = .t.
					.Release
		
			ENDCASE
		
		ENDWITH
		
		RETURN
	ENDPROC

	PROCEDURE getcontainerform		&& Returns the container form of the passed name
		*-- given an main VFP obj and a name, get the container form name
		LPARAMETERS oAccVfp, cFormString, lFormTitleBar, lSet16
		
		LOCAL cFormCaption, oRet, nChilds, nSys2800
		
		cFormCaption = ""
		
		oRet = .Null.
		
		*-- Store the value of accessibility settings
		nSys2800 = This.oVfp.Eval("SYS(2800)")
		
		IF lSet16
		  This.oVfp.DoCmd("SYS(2800, 17)")
		ELSE
		  This.oVfp.DoCmd("SYS(2800, 1)")
		ENDIF
		
		
		nChilds=oAccVfp.accChildCount()
		
		*-- Loop for all the top level objects
		FOR i = 1 to nChilds
			
			cFormCaption = oAccVfp.accChild(i).accname(0)
			
			DO CASE
				CASE ISNULL(cFormCaption)
					*-- ignore if there is no name
				CASE ATC(cFormCaption, cFormString) > 0
					*-- If the form(inputbox window...) exists
					oRet = oAccVfp.accChild(i)
			
				CASE ATC(cFormCaption, This.ovfp.Caption) > 0
					*-- if its a VFP object check for each forms (browse window...) inside
		
					FOR j = 1 TO oAccVfp.accChild(i).AccChildCount()
						cFormCaption = oAccVfp.accChild(i).accChild(j).accname(0)
						
						*-- If the form(inputbox window...) exists
						IF VARTYPE(cFormCaption) = "C" AND ATC(cFormCaption, cFormString) > 0
							oRet = oAccVfp.accChild(i).accChild(j)
							EXIT
						ENDIF
					ENDFOR
					
			ENDCASE
			
			*-- If there is a matching window, don't check other objects
			IF NOT ISNULL(oRet)
				*-- Pass the form name as refrerence
				cFormString = cFormCaption
				EXIT
			ENDIF
		
		ENDFOR
		
		*-- Restore the value of accessibility settings
		This.oVfp.DoCmd("SYS(2800, " + nSys2800 + ")")
		
		RETURN oRet
	ENDPROC

	PROCEDURE geteventvalue		&& Method to get the Event Value based on directive and event.
	ENDPROC

	PROCEDURE getobjwithname
		*given an obj and a name, get the child with that name
		LPARAMETERS oAcc, cName
		
		LOCAL nObtained, sChildren, nc, i, otmp, oret, cvar, vt, otmp
		oret = .Null.
		nc = oAcc.accChildCount
		nObtained = 0
		sChildren = REPLICATE(CHR(0), m.nc * 16)
		
		IF m.nc > 0 
			i = AccessibleChildren(SYS(3095, oAcc, "{"+IAccguid+"}"), 0, m.nc, @sChildren, @nobtained)
			SYS(3098,oAcc)
		
			IF m.i= 0
				FOR i = 1 TO m.nc
					cvar = SUBSTR(m.sChildren, 1 + ((m.i - 1) * 16), 16)
					vt = THIS.Str2Num(m.cvar)
					DO CASE
					CASE m.vt = 9 	&& VT_DISPATCH
						otmp = SYS(3096,THIS.Str2Num(SUBSTR(m.cvar,9)))
		
						IF TYPE("m.otmp.accname[0]") = "C" AND upper(m.otmp.accname[0]) = UPPER(m.cName)
							oret = m.otmp
							* must continue loop so all IDisp get released
						ENDIF
					OTHERWISE
		*!*					?"help"
		*!*					SET STEP ON
					ENDCASE
				ENDFOR
		
			ELSE
				* AccessibleChildren doesn't work.. try each child obj directly
				FOR i = 1 TO m.nc
					otmp = m.oAcc.accChild(i)
					IF UPPER(m.cName) = UPPER(m.otmp.accName(0))
						oret = m.otmp
						EXIT
					ENDIF
				ENDFOR
			ENDIF
		
		ENDIF
		
		*!*	IF ISNULL(m.oret)
		*!*		WAIT WIND 'object ' + m.cName + " doesn't exists"
		*!*		SUSPEND
		*!*	ENDIF
		
		RETURN m.oret
		
	ENDPROC

	PROCEDURE getobjwithrole
		*given an obj and a role, get the child with the role
		LPARAMETERS oAcc, nRole
		LOCAL oret, i, otmp
		oret = .null.
		FOR i = 1 TO oAcc.accChildCount
			otmp = oAcc.accChild(i)
			IF nrole = m.otmp.accrole(0)
				oret = m.otmp
				EXIT
			ENDIF
		ENDFOR
		RETURN oret
		
		*!*	nRole = ox.accRole(nRoleIndex)
		*!*	cstr = SPACE(256)
		*!*	nPos = GetRoleText(nRole, @cstr, len(cstr))
		*!*	cstr = LOWER(ALLTRIM(LEFT(cstr,nPos)))
		
		*!*	DO CASE
		*!*	CASE cStr == "application"
		*!*		Return "application"
		*!*	CASE cStr == "check box"
		*!*		Return "checkbox"
		*!*	CASE cStr == "client"
		*!*		Return "client"
		*!*	CASE cStr == "column"
		*!*		Return "column"
		*!*	CASE cStr == "column header"
		*!*		Return "colheader"
		*!*	CASE cStr == "combo box"
		*!*		Return "combo"
		*!*	CASE cStr == "editable text"
		*!*		Return "editbox"
		*!*	CASE cStr == "graphic"
		*!*		Return "image"
		*!*	CASE cStr == "grouping"
		*!*		Return "group"
		*!*	CASE cStr == "list"
		*!*		Return "list"
		*!*	CASE cStr == "list item"
		*!*		Return "listitem"
		*!*	CASE cStr == "popup menu"
		*!*		Return "popupmenu"
		*!*	CASE cStr == "push button"
		*!*		Return "button"
		*!*	CASE cStr == "radio button"
		*!*		Return "radio"
		*!*	CASE cStr == "spin box"
		*!*		Return "spinner"
		*!*	CASE cStr == "table"
		*!*		Return "table"
		*!*	CASE cStr == "text"
		*!*		Return "label"
		*!*	CASE cStr == "tool bar"
		*!*		Return "toolbar"
		*!*	CASE cStr == "unknown object"
		*!*		Return "unknown"
		*!*	CASE cStr == "window"
		*!*		Return "window"
		*!*	CASE cStr == "scroll bar"
		*!*		Return "scrollbar"
		*!*	CASE cStr == "grip"
		*!*		Return "sizebox"
		*!*	CASE cStr == "indicator"
		*!*		Return "indicator"
		*!*	CASE cStr == "status bar"
		*!*		Return "statusbar"
		*!*	CASE cStr == "menu bar"
		*!*		Return "menubar"
		*!*	CASE cStr == "menu item"
		*!*		Return "menuitem"
		*!*	CASE cStr == "link"
		*!*		Return "link"
		*!*	CASE cStr == "title bar"
		*!*		Return "titlebar"
		*!*	CASE cStr == "separator"
		*!*		Return "separator"
		*!*	CASE cStr == "page tab list"
		*!*		Return "pageframe"
		*!*	CASE cStr == "page tab"
		*!*		Return "pageframe"
		*!*	CASE cStr == "dialog"
		*!*		Return "proppage"
		*!*	CASE cStr == "property page"
		*!*		Return "proppage"
		*!*	ENDCASE
		
		*!*	Return "unknown"
		
		
	ENDPROC

	PROCEDURE gettestinfo		&& Accepts the record details like test log
		LOCAL	lReturn
		
		lReturn = .t.
		
		WITH This
		
			.cTestName = ""
		
			.trectime = DATETIME()
		
			*-- if there is a form exists
			IF TYPE('.oVFP.Forms(1).Caption') = "C"
				.cTestCaption = .oVFP.Forms(1).Caption
			ELSE
				*-- If there is no form exists, just store the VFP window name
				.cTestCaption = .oVFP.Caption
			ENDIF
		
			DO WHILE NOT .lPlayInsert
				.cTestName = INPUTBOX(MSG_TESTNAME_LOC, WINDOWTITLE_LOC, .cTestName)
				
				*-- If its cancelled 
				IF EMPTY(.cTestName)
					lReturn = .f.
					EXIT
				ENDIF
		
				SELECT aascripts
		
				LOCATE FOR UPPER(desc) = UPPER(LEFT(.cTestName, LEN(desc)))
				
				IF FOUND()
					
					*-- If overwrite script has been checked
					IF NOT This.frmMain.pgfmain.Page2.chkOverwriteScript.Value AND ;
						MESSAGEBOX(MSG_SCRIPTEXIST_LOC, WINDOWTITLE_LOC, 4+32) = 7
						LOOP
					ELSE
						EXIT	
					ENDIF
					
				ELSE
					EXIT
				ENDIF
					
			ENDDO
			
		ENDWITH
		
		RETURN lReturn
	ENDPROC

	PROCEDURE hex2val
		LPARAMETERS cstr
		LOCAL lcChars
		lcChars = "0123456789abcdef"
		RETURN (ATC(LEFT(m.cstr, 1), lcChars) - 1) * 16 + (ATC(RIGHT(m.cstr, 1), lcChars) - 1)
		
	ENDPROC

	PROCEDURE Init
		PUSH MENU _MSYSMENU
		DO aatest.mpr
		
		PUSH KEY CLEAR
		
		ThisformSet.cStatePrev = Cc_StateIdle
		ThisformSet.cState = Cc_StateIdle
		
		DECLARE integer Sleep IN kernel32 integer
		DECLARE integer keybd_event IN win32api integer, integer, integer, integer
		DECLARE integer GetRoleText IN oleacc.dll integer, string @, integer
		DECLARE integer SetForegroundWindow IN win32api integer
		DECLARE integer SendInput IN win32api integer, string, integer
		DECLARE integer FindWindow IN win32api string, string
		DECLARE integer AccessibleObjectFromWindow IN oleacc.dll integer, integer, string , object @
		DECLARE integer AccessibleChildren IN oleacc.dll integer pAcc, integer childStart, integer nchildren, string @, integer @
		
		This.cScreenCaption = _Screen.Caption 
		_Screen.Caption = WINDOWTITLE_LOC
		This.frmMain.Caption = WINDOWTITLE_LOC
		
		*-- define special keys here
		WITH This
			DIMENSION .aSplKeys[21, 2]
		
			.aSplKeys[1,1] = 33
			.aSplKeys[1,2] = "PGUP"
			.aSplKeys[2,1] = 34
			.aSplKeys[2,2] = "PGDN"
			.aSplKeys[3,1] = 35
			.aSplKeys[3,2] = "END"
			.aSplKeys[4,1] = 36
			.aSplKeys[4,2] = "HOME"
			.aSplKeys[5,1] = 37
			.aSplKeys[5,2] = "LEFTARROW"
			.aSplKeys[6,1] = 38
			.aSplKeys[6,2] = "UPARROW"
			.aSplKeys[7,1] = 39
			.aSplKeys[7,2] = "RIGHTARROW"
			.aSplKeys[8,1] = 40
			.aSplKeys[8,2] = "DNARROW"
		
		
			.aSplKeys[9,1] = 112
			.aSplKeys[9,2] = "F1"
			.aSplKeys[10,1] = 113
			.aSplKeys[10,2] = "F2"
			.aSplKeys[11,1] = 114
			.aSplKeys[11,2] = "F3"
			.aSplKeys[12,1] = 115
			.aSplKeys[12,2] = "F4"
			.aSplKeys[13,1] = 116
			.aSplKeys[13,2] = "F5"
			.aSplKeys[14,1] = 117
			.aSplKeys[14,2] = "F6"
			.aSplKeys[15,1] = 118
			.aSplKeys[15,2] = "F7"
			.aSplKeys[16,1] = 119
			.aSplKeys[16,2] = "F8"
			.aSplKeys[17,1] = 120
			.aSplKeys[17,2] = "F9"
			.aSplKeys[18,1] = 121
			.aSplKeys[18,2] = "F10"
			.aSplKeys[19,1] = 122
			.aSplKeys[19,2] = "F11"
			.aSplKeys[20,1] = 123
			.aSplKeys[20,2] = "F12"
		
			.aSplKeys[21,1] = 9
			.aSplKeys[21,2] = "TAB"
		
		ENDWITH
		
		SET MEMOWIDTH TO 255
		**-----------------------debug hook
		PUBLIC gl_pause
		gl_Pause = .f.
		
		ON KEY LABEL CTRL+F9 gl_Pause = .t.
		
		
	ENDPROC

	PROCEDURE keybrd
		LPARAMETERS nChar, nVK
		
		LOCAL nElement, nSubscript, cKeyString, lAlt, lShift, lCtrl
		
		cKeyString = ""
		
		lShift	= BITTEST(nVK, 12)	&& shift - 4096	
		lCtrl	= BITTEST(nVK, 13)	&& ctrl - 8192
		lAlt	= BITTEST(nVK, 14)	&& alt - 16384
		
		WITH THIS
			nElement = ASCAN(.aSplKeys, nChar)
		
			DO CASE
				CASE nElement > 0 OR lAlt && If special keys like HOME, END... found OR ALT key is pressed
					*-- ALT + Any key press is not working fine so pass the keyboard command
		
					cKeyString = "KEYBOARD '{"
		
					IF lShift
						cKeyString = cKeyString + "SHIFT+"
					ENDIF
		
					IF lCtrl
						cKeyString = cKeyString + "CTRL+"
					ENDIF
		
					IF lAlt
						cKeyString = cKeyString + "ALT+"
					ENDIF
		
					IF nElement > 0  && if special keys found
						nSubscript = ASUBSCRIPT(.aSplKeys, nElement, 1)
						cKeyString = cKeyString + .aSplKeys[nSubscript, 2] + "}'"
					ELSE
						*-- just for alt+keys
						cKeyString = cKeyString + CHR(nChar) + "}'"
					ENDIF
					
					IF NOT (lAlt AND nChar = 18) && ignore for just alt key
						.oVFP.Docmd(cKeyString)
						SLEEP(200)	&& let it execute the on key routines
					ENDIF
		
				CASE nVK = 0  && plain
					KEYBD_EVENT(nChar,0,0,0)
					KEYBD_EVENT(nChar,0,KEYEVENTF_KEYUP,0)
				CASE lShift && shift
					KEYBD_EVENT(VK_LSHIFT,0,0,0)
					KEYBD_EVENT(nChar,0,0,0)
					KEYBD_EVENT(nChar,0,KEYEVENTF_KEYUP,0)
					KEYBD_EVENT(VK_LSHIFT,0,KEYEVENTF_KEYUP,0)
				CASE lCtrl && ctrl
					KEYBD_EVENT(VK_LCONTROL,0,0,0)
					KEYBD_EVENT(nChar,0,0,0)
					KEYBD_EVENT(nChar,0,KEYEVENTF_KEYUP,0)
					KEYBD_EVENT(VK_LCONTROL,0,KEYEVENTF_KEYUP,0)
		*!*			CASE nVK = 16394 && alt
		*!*				KEYBD_EVENT(VK_LMENU,0,0,0)
		*!*				KEYBD_EVENT(VK_LMENU,0,KEYEVENTF_KEYUP,0)
		*!*				KEYBD_EVENT(nChar,0,0,0)
		*!*				KEYBD_EVENT(nChar,0,KEYEVENTF_KEYUP,0)
			ENDCASE
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE launchhelp		&& Invoke the help
		LOCAL oBrowser
		
		oBrowser=CREATEOBJECT("internetexplorer.application")
		oBrowser.navigate(FULLPATH("")+'aatesthelp.htm')
		oBrowser.Visible = .t.
		
		RETURN
	ENDPROC

	PROCEDURE launchvfp		&& Launch VFP
		LOCAL oExternalVFP
		
		oExternalVFP = CREATEOBJECT("visualfoxpro.application")
		
		oExternalVFP.Visible = .T.
		
		RETURN
	ENDPROC

	PROCEDURE Load
		LOCAL	lReturn, ;
				cSetPath
		
		lReturn = .t.
		
		SET TALK OFF
		SET DELETED ON
		SET SAFETY OFF
		SET EXACT ON
		
		This.cSetEscape = SET("ESCAPE")
		
		IF (SET('RESOURCE') = 'ON')
			This.cResourceFile = SET("RESOURCE", "TO")
			SET RESOURCE OFF
		ELSE
			This.cResourceFile = ""
		ENDIF
		
		SET ESCAPE OFF
		
		cSetPath = SET('PATH')
		
		IF EMPTY(cSetPath)
			SET PATH TO (TESTHARNESSPATH_LOC)
		ELSE
			SET PATH TO (cSetPath + ',' + TESTHARNESSPATH_LOC)
		ENDIF
		
		*-- Initialize the global object
		This.oGlobal = NEWOBJECT("cstglobal", "aautils")
		
		This.cGuid = This.Str2Guid(IAccGuid)	&& IAccecssible
		
		lReturn = lReturn AND NOT This.lError AND This.OpenTable()
		
		RETURN lReturn
	ENDPROC

	PROCEDURE logerror		&& Logs the error messages
		LPARAMETERS cErrorMessage, nError
		
		LOCAL	cMessage, ;
				cLogMessage
		
		cLogMessage = ""
		cMessage    = ""	
		
		WITH This
		
			*-- if there is an error in the application
			*-- Dont check .oVFP because the application may have closed 
			IF .frmMain.pgfmain.Page2.chkVFPError.Value AND nError <> Cc_TestPassed AND ;
			  TYPE("Thisformset.oVFP.Caption") = "C" AND ;
			  .cFoxError <> .oVFP.Eval("MESSAGE()")
		
				.cFoxError = .oVFP.Eval("MESSAGE()")
				cMessage = cErrorMessage + Cc_EOL + MSG_ERROR1_LOC + "'" + .cFoxError + [']
		
			ELSE
				cMessage = cErrorMessage
			ENDIF
		
			DO CASE
				CASE nError = Cc_Error
					cLogMessage = "Error : " + cMessage
				CASE nError = Cc_Warning
					cLogMessage = "Warning : " + cMessage
				OTHERWISE
					cLogMessage = cMessage
			ENDCASE
		
			INSERT INTO errorlist VALUES (cLogMessage, (nError = Cc_Error))
		
			cMessage = MSG_PLAYBACKERROR_LOC + cErrorMessage + CHR(13) + MSG_CHKLOG_LOC
		
			*-- If its error (not warning)
			IF nError = Cc_Error
				.lError = .t.
				.frmMain.edtStatus.Value = .frmMain.edtStatus.Value + cMessage + CHR(13)
		
				IF TYPE("Thisformset.oVFP.Caption") = "C"
					.oVFP.DoCmd("MESSAGEBOX([" + cMessage + "], 0, [" + WINDOWTITLE_LOC + "], 10000)")
				ENDIF
		
			ENDIF
		
		ENDWITH
		
		RETURN
	ENDPROC

	PROCEDURE opentable
		CREATE CURSOR errorlist(errormsg c(200), error L)
		
		CREATE CURSOR tBreakPoint (scriptId N(6), ;
		                           scriptLineNo I(4))
		INDEX ON STR(scriptId, 6) + STR(scriptLIneNo, 8) TAG scriptId1
		
		SELECT 0
		USE aatestlog.dbf ALIAS aatestlog EXCLUSIVE
		
		IF EMPTY(ALIAS())
			MESSAGEBOX(MSG_ERROR_OPN1_LOC, WINDOWTITLE_LOC, 16)
			RETURN .F.
		ENDIF
		
		REPLACE ALL selected WITH .f.
		GO TOP
		
		SELECT 0
		USE aascripts.dbf ALIAS aascripts EXCLUSIVE
		
		IF EMPTY(ALIAS())
			MESSAGEBOX(MSG_ERROR_OPN2_LOC, WINDOWTITLE_LOC, 16)
			RETURN .F.
		ENDIF
		
		SELECT aascripts
		
		REPLACE ALL selected WITH .f.
		GO TOP
		
		RETURN .t.
	ENDPROC

	PROCEDURE play		&& Play the selected script
		LOCAL	lContinue, ;
				oAcc, ;
				nRetval
		
		lContinue = .t.
		
		WITH This
		
			.lError = .f.
			.oVFP   = NULL
		
			IF NOT .lPlayPaused
				SELECT aascripts
		
				LOCATE FOR selected
		
				IF NOT FOUND()
					MESSAGEBOX(MSG_NOSCRIPT2_LOC, WINDOWTITLE_LOC, 16)
					lContinue = .f.
				ENDIF
		
				IF lContinue
		
			      *-- If checked to create a new instance of VFP
			      IF .frmMain.pgfmain.Page2.chkNewVFP.Value
			      
			        .oVFP = CREATEOBJECT("visualfoxpro.application")
			        .nTestAppHWnd = .oVFP.hWnd
			        .oVFP.Visible=.T.
		
			      ELSE
			  			.nTestAppHWnd = .oGlobal.SelApplication(.frmMain.HWnd)
			  			*-- don't proceed if there is no applications selected
			  			lContinue = (.nTestAppHWnd > 0)
			      ENDIF
		
				ENDIF
		
				IF lContinue
		
					oAcc = 0
		
					**
					nRetval = AccessibleObjectFromWindow(.nTestAppHWnd, OBJID_CLIENT, .cguid, @oAcc)
		
		      IF NOT .frmMain.pgfmain.Page2.chkNewVFP.Value
		
		        IF TYPE("oacc.accchild(int(2^31-1))") # "U"
		          .oVFP = oAcc.accchild(int(2^31-1))
		        ENDIF
		
		      ENDIF
		
					DO CASE
						CASE NOT (TYPE("This.oVFP.Name") # "U" AND This.oVFP.Name = "Microsoft Visual FoxPro")
							*-- If its not VFP application
							MESSAGEBOX(MSG_NONVFP_LOC, WINDOWTITLE_LOC, 16)
							lContinue = .f.
						CASE .oVFP.StartMode > 1
							*-- Runtime libraries
							MESSAGEBOX(MSG_RUNTIME_LOC, WINDOWTITLE_LOC, 16)
							lContinue = .f.
					ENDCASE
		
				ENDIF
				
			ENDIF && NOT .lPlayPaused
		
			IF lContinue AND NOT .lError
		
				*-- Turn on coverage logging
				IF This.frmMain.pgfmain.Page4.chkcovelogon.Value AND NOT EMPTY(.cCoverLogFile)
		
					IF This.frmMain.pgfmain.Page4.chkoverwritecovlog.Value
						 .oVFP.DoCmd("SET COVERAGE TO " + .cCoverLogFile)
					ELSE
						 .oVFP.DoCmd("SET COVERAGE TO " + .cCoverLogFile + " ADDITIVE")
					ENDIF
		
				ENDIF			 
		
				SetForegroundWindow(.nTestAppHWnd)
		
				.cState = Cc_StatePlay
				.lError = .f.
		
				.PlayLoop()
		
				IF .lPlayPaused
					.cState = Cc_StatePlayPause
				ELSE
				
				 	*-- Reset the coverage logging
					IF This.frmMain.pgfmain.Page4.chkcovelogon.Value AND NOT EMPTY(.cCoverLogFile)
						 .oVFP.DoCmd("SET COVERAGE TO ")
					ENDIF		 
		
					*-- Bring back the test application
					SetForegroundWindow(_VFP.hWnd)
		
					IF .lError
						This.frmMain.edtStatus.Value = This.frmMain.edtStatus.Value + MSG_PLAYBACKERROR_LOC + MSG_PLAYBACK10_LOC + CHR(13)
					ELSE
						This.frmMain.edtStatus.Value = This.frmMain.edtStatus.Value + MSG_RUNS_OVER_LOC + CHR(13)
					ENDIF
					
					.cState = Cc_StateIdle
		
				ENDIF
		
			ENDIF
			
		ENDWITH
		
		RETURN
	ENDPROC

	PROCEDURE playbegin		&& play begining hook
		*-- Do the processing before start playing the script
		
		*-- empty the errorlog cursor
		ZAP IN errorlist
		
		WITH This
			*-- Record the begining memory and time
			.nDuration = SECONDS()
			.nMemoryUsage = .oVFP.Eval(SYS(1016))
			.cFoxError = .oVFP.Eval("MESSAGE()")
		
			.nHistcnt = 0
			DIMENSION .ahist[.nCacheSize,2]
		
			* Run PreScript
			IF !EMPTY(ALLTRIM(aascripts.prescript))
				EXECSCRIPT(aascripts.prescript,THIS)
				SLEEP(1000)
			ENDIF
		
		ENDWITH
	ENDPROC

	PROCEDURE playend		&& play end hook
		LOCAL cErrorLogFile
		
		LOCAL ARRAY aTestId[1]
		
		*-- log the error
		
		cErrorLogFile = SYS(2015)+".txt"
		
		WITH This
		
			*-- If there is no error
			IF NOT .lError
				* Run PostScript
				*-- 1. if there is no error
				*-- 2. if the second VFP application is not closed
				IF !EMPTY(aascripts.postscript) AND NOT .lerror AND TYPE("Thisformset.oVFP.Caption") = "C"
					SLEEP(2000)
					EXECSCRIPT(aascripts.postscript,THIS)
				ENDIF
		
				.nDuration = SECONDS() - .nDuration
				
				SLEEP(1500)
		
				.LogError(MSG_TESTPASSED_LOC, Cc_TestPassed)
			ELSE
				.nDuration = SECONDS() - .nDuration
			ENDIF
		
			*-- If the 2nd VFP application is closed
			IF TYPE("Thisformset.oVFP.Caption") = "C"
				.nMemoryUsage = .oVFP.Eval(SYS(1016)) - .nMemoryUsage
			ELSE
				.nMemoryUsage = 0
			ENDIF
		
			SELECT errorlist
		
			COPY FIELD errormsg TO (cErrorLogFile) TYPE SDF
		
			SELECT MAX(testid) FROM aatestlog INTO ARRAY aTestId
			aTestid = IIF(EMPTY(aTestId), 1, aTestId + 1)
		
			INSERT INTO aatestlog (testid, scriptid, iterno, name, notes, results, passed, objcount, memuse, duration, playtime) ;
					VALUES(aTestid, .ntestid, .ntestrun, aascripts.desc, ;
					"", FILETOSTR(cErrorLogFile), NOT .lError, 0, .nMemoryUsage, .nDuration, DATETIME())
		
			ERASE (cErrorLogFile)
		
			IF NOT .lError AND TYPE("Thisformset.oVFP.Caption") = "C"
		        cMessage = MSG_TESTRUN_LOC
		        This.oVFP.DoCmd("MESSAGEBOX([" + cMessage + "],0, [" + WINDOWTITLE_LOC + "], 10000)")
			ENDIF
		
		ENDWITH
		
		RETURN
	ENDPROC

	PROCEDURE playloop
		LOCAL lnRunNum
		
		WITH This
		
			IF .lplaypaused
				lnRunNum = .nPlayPausedRun
			ELSE
				lnRunNum = 1
			ENDIF
		
			DO WHILE lnRunNum <= .nRunCount
		
				*-- Store current run to play pause property so we can
				*-- continue at that run when play is resumed
				.nPlayPausedRun = lnRunNum
		
				This.frmMain.edtStatus.Value = This.frmMain.edtStatus.Value + MSG_TESTRUNNO_LOC + TRANSFORM(lnRunNum) + CHR(13)
		
				SELECT aaScripts
		
				IF .lplaypaused
					GOTO .nPlayPausedScriptRecno IN aaScripts
				ELSE
					GOTO TOP IN aaScripts
				ENDIF
					
				SCAN REST FOR selected
					*-- Store current recno of scripts table to play pause property so we can
					*-- continue at that script when play is resumed
					.nPlayPausedScriptRecno = RECNO("aaScripts")
		
					.frmMain.edtStatus.Value = .frmMain.edtStatus.Value + "    Script:"+ aascripts.desc + CHR(13)
					
					.nTestId = id
					.nTestRun = lnRunNum
					
					IF NOT .lplaypaused
						.PlayBegin()
					ENDIF
		
					.PlayTest()
					
					IF .lPlayPaused
						EXIT
					ENDIF
					
					.PlayEnd()
					
					*-- If there is an error exit the loop
					IF .lError
						EXIT
					ENDIF
					
					SELECT aaScripts
				ENDSCAN && REST FOR selected
		
				*-- If there is an error exit the loop
				IF This.lerror
					EXIT
				ENDIF
		
				lnRunNum=lnRunNum+1
			ENDDO && lnRunNum <= .nRunCount
		
		ENDWITH
		
		RETURN
	ENDPROC

	PROCEDURE playresume		&& Method to resume play from where it had been stopped before.
		WITH This
			*-- Just play. .lPlayPaused will be used by play and methods it
			*-- calls to handle resuming at exact point play was stopped
			.Play()
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE playstop		&& Method to handle play getting stopped.
		WITH This
			.lPlayPaused = .f.
			This.cState = Cc_StateIdle
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE playtest		&& Play a test script
		LOCAL hWnd, oAccvfp, oAcc, lclogfile, lcStr, lcfullname, nRetval
		LOCAL frmLeft, frmTop, frmWidth, frmHeight
		LOCAL oForm, cFormName, lFormTitleBar, oAccObj
		LOCAL nTimeInterval
		LOCAL lc_Eval, lc_Do, lc_If, lc_CurrentEventLine, lc_Exact
		
		STORE 0 TO frmLeft, frmTop, frmWidth, frmHeight
		
		oAccObj = Null
		
		lFormTitleBar = .t.
		
		WITH This
			oAcc = 0
		
			nRetval = AccessibleObjectFromWindow(.nTestAppHWnd, OBJID_CLIENT, .cguid, @oAcc)
		
			** this can be stored in a property
			oAccvfp = oAcc
		
			*-- if its not started from the command window
			IF ATC(aascripts.caption, .oVfp.Caption) = 0
		
				cFormName = aascripts.caption
		
				*-- find startup form/window
				oForm = .GetContainerForm(oAccvfp, cFormName)
		
				*-- If the start up form is different
				IF ISNULL(oForm)
		
					IF .frmMain.pgfmain.Page2.chkStartupWin.Value
						.LogError(MSG_WRONGSTARTWINDOW_LOC, Cc_Error)
						This.frmMain.edtStatus.Value = This.frmMain.edtStatus.Value + "Script Failure!" + CHR(13)
						RETURN
					ELSE
						.LogError(MSG_WRONGSTARTWINDOW_LOC, Cc_Warning)
					ENDIF
		
				ELSE
					oAcc = oForm
					.cCurrWinName = cFormName
					.cCurrFormName = cFormName
				ENDIF
		
			ENDIF
		
			.nAppLeft = aascripts.AppLeft
			.nAppTop  = aascripts.AppTop
			.nScreenLeft = aascripts.ScreenLeft
			.nScreenTop  = aascripts.ScreenTop
		
			lclogfile = SYS(2015)+".txt"
			STRTOFILE(aascripts.script,lclogfile)
		
			CREATE CURSOR EVENTS(event c(12), eventid c(8), mx n(6), my n(6), ;
								params c(20), rest c(115),delay n(11,5), foxEvt L)
		
			APPEND FROM (lclogfile) sdf
			ERASE (lcLogFile)
		
			IF .lPlayPaused
				GOTO .nPlayPausedLine IN events
				SKIP IN events
				
				*-- We have handled resuming from where we left off so turn of playpaused indicator
				.lPlayPaused = .f.
			ELSE
				GOTO TOP IN events
			ENDIF
		
			.cLastevent = "    "
		
			* Run EventScript
			SCAN REST
		
				*-- The Cc_Directive token indicates that the script has been edited
				*-- and needs to run something different.
				IF LEFT(LTRIM(events->event), 1) = Cc_Directive OR EMPTY(events->event)
		
					lc_Exact = SET("EXACT")
					SET EXACT OFF
					
					*-- Find the full line from the script field
					lc_CurrentEventLine = MLINE(aaScripts->script, RECNO("events"))
					
					DO CASE
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "COMMAND "
							*-- We have a command to execute
							lc_Command = SUBSTR(lc_CurrentEventLine, LEN(Cc_Directive + "COMMAND ") + 1)
							&lc_Command.
							SELECT events
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "="
							*-- We have a function to execute
							lc_Eval = SUBSTR(lc_CurrentEventLine, LEN(Cc_Directive + "=") + 1)
							= EVALUATE(lc_Eval)
							SELECT events
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "DO "
							*-- We have a DO command to execute
							lc_Do = SUBSTR(lc_CurrentEventLine, LEN(Cc_Directive + "DO ") + 1)
							DO &lc_Do.
							SELECT events
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "IF "
							*-- We have an IF condition to evaluate
							lc_If = SUBSTR(lc_CurrentEventLine, LEN(Cc_Directive + "IF ") +1)
							
							IF NOT EVALUATE(lc_If)
								SELECT events
								*-- If condition failed. Find ELSE or ENDIF
								LOCATE REST FOR UPPER(LTRIM(events->event)) = Cc_Directive + "ELSE" OR ;
									UPPER(LTRIM(events->event)) = Cc_Directive + "ENDIF"
							ELSE
								SELECT events
							ENDIF
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "ENDIF"
							*-- ENDIF given. Just do nothing.
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "ELSE"
							*-- ELSE given. Go to line after ENDIF.
							LOCATE WHILE UPPER(LTRIM(events->event)) <> Cc_Directive + "ENDIF"
		
						CASE UPPER(LTRIM(events->event)) = Cc_Directive + "<PAUSE>"
							*-- DO NOT REMOVE!!! W/o the wait window the last set of
							*-- events do not seem to get fired.
							WAIT WINDOW MSG_PLAYBACK2_LOC TIMEOUT 2.0
		
							*-- Bring back the test application
							SetForegroundWindow(_VFP.hWnd)
		
							*-- Note that we have paused
							.frmMain.edtStatus.Value = This.frmMain.edtStatus.Value + ;
								MSG_PLAYBACK2_LOC + CHR(13)
							.frmMain.edtStatus.Refresh(.t.)
							.lPlayPaused = .t.
							.nPlayPausedLine = RECNO("events")
							
							*-- Stop playing
							EXIT
					ENDCASE
		
					SET EXACT &lc_Exact.
		
					*-- Loop back for other directives
					LOOP
				ENDIF
				
				*-- Skip consecutive mouse up & down
				IF event = .cLastevent AND (event = "MouseDown" OR event = "MouseUp")
					LOOP
				ENDIF
				
				.cLastevent = event
		
				nTimeInterval = events.delay * 1000 + .nDelay
		
				SLEEP(nTimeInterval)
		
				*-- If coordinates not relative to main vfp window and the script is not for the current form
				*-- don't check if the form caption/name is empty for keypress event
				IF ATC(.oVfp.Caption,rest) = 0 AND ;
					ATC(.cCurrWinName, rest) = 0 AND ATC(.cCurrFormName, rest) = 0 AND ;
					NOT (ATC("KeyPress", event) # 0 AND EMPTY(rest))
		
					*-- Find out the present top form name
					*-- the validity of the top name is done in the doTheEvent method
				
					*-- Clear the form object which will prevent closing the form
					oForm = NULL
					
					*-- Rest to have form titlebar by default
					lFormTitleBar = .t.
		
					*-- Wait for the new form to load
					SLEEP(1000)
		
					*-- If the top form is not the next object
					IF TYPE(".oVFP.Forms(1).Name") # "C" OR ATC(.oVFP.Forms(1).Name, rest) = 0
		
						*-- Send the whole string, not sure about the form name/caption
						*-- recevied the form name/caption only
						cFormName = rest
		
						oForm = .GetContainerForm(oAccvfp, @cFormName, @lFormTitleBar)
		
		        IF ISNULL(oForm)
		          *-- Call again with checking for name instead of caption
		          oForm = .GetContainerForm(oAccvfp, @cFormName, @lFormTitleBar, .t.)
		        ENDIF
		        
						*-- If the object is not able to find, log the error and exit
						IF ISNULL(oForm)
		
							DO CASE
								*-- Abort playback
								CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 1
									.LogError(MSG_NOFOCUS_LOC + " " + MSG_SCRIPTLINE_LOC + STR(RECNO("events")), Cc_Error)
									EXIT
		
								*-- Skip only the current event
								CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 2
									LOOP
		
								*-- Continue playback
								CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 3
							ENDCASE
		
						ELSE
							oAcc = oForm
							.cCurrWinName = cFormName
							.cCurrFormName = cFormName
						ENDIF
		
					ELSE
						oForm = .oVFP.Forms(1)
		
						*-- Check whether there is a titlebar for the form
						*-- the toolbars doesn't have titlebar prop
						IF TYPE("oForm.TitleBar") = "N" AND oForm.TitleBar = 0 ;
							OR EMPTY(oForm.Caption)
							.cCurrWinName = oForm.Name
							*-- Set the variable which will be used to calculate the position without titlebar
							lFormTitleBar = .f.
						ELSE
							.cCurrWinName = oForm.Caption
						ENDIF
		
						.cCurrWinName = oForm.Name
		
						oAcc=0
						nRetval = AccessibleObjectFromWindow(oForm.hwnd, OBJID_CLIENT, .cguid, @oacc)
		
					ENDIF
		
					*-- Find the location if the container form exists
					IF NOT ISNULL(oAcc)
						oAcc.accLocation(@frmLeft, @frmTop, @frmWidth, @frmHeight, 0)
						.nFrmLeft = frmLeft
						.nFrmTop = frmTop
						.nFrmWidth = frmWidth
						.nFrmHeight = frmHeight
					ENDIF
		
				ENDIF
		
				*-- Do not check the object if
				*--		-object level check is enabled
				*--		-its keypress event without the object names (win event)
				*--		-the object is the topmost, ie window itself
				IF .frmMain.pgfmain.Page2.chkObjectLevel.Value AND ;
					NOT (ATC("KeyPress", event) # 0 AND EMPTY(rest)) AND ;
					NOT (EMPTY(STRTRAN(rest, .cCurrWinName, "")) OR ;
					     AT(".", STRTRAN(rest, .cCurrWinName, "")) = 0 OR ;
					     EMPTY(STRTRAN(rest, .cCurrFormName, "")) OR ;
					     AT(".", STRTRAN(rest, .cCurrFormName, "")) = 0)
		
					*-- If the object is not able to find, log the error and exit
					*-- Check the focus only for keypress
					IF NOT .CheckTheObj(oAcc, ALLTRIM(rest), (ATC("KeyPress", event) > 0), @oAccObj)
		
						DO CASE
							*-- Abort playback
							CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 1
								EXIT
		
							*-- Skip only the current event
							CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 2
								LOOP
		
							*-- Continue playback
							CASE This.frmMain.pgfmain.Page2.opgfailoption.Value = 3
						ENDCASE
		
					ENDIF
		
				ENDIF
		
				.DoTheEvent(oAccObj, ALLTRIM(rest), ALLTRIM(event), mx, my, lFormTitleBar)
		
				*-- Clear the form object which will prevent closing the form
				oForm = NULL
				
				oAccObj = NULL
		
		
				*-- If there is an error exit the loop
				IF .lerror
					EXIT
				ENDIF
		
				IF TYPE("gl_Pause") <> "U" AND gl_Pause
					WAIT WIND MSG_SUPSEND_LOC TIMEOUT 1
					debug
					suspend
				ENDIF
		
			ENDSCAN
		
			*-- Clear the form object which will prevent closing the form
			oForm = NULL
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE record		&& Record script
		WITH This
		
			IF .RecordBegin()
				*-- Change the state
				.cState = Cc_StateRecord
			ENDIF
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE recordbegin		&& Record begining hook
		WITH This
		
			LOCAL nhWnd, oAccvfp, oAcc, nRetval, cRecOnScript, lContinue, oExternalVFP, cTmpStr
			
			lContinue = .t.
			.lError = .f.
		
			.cEventLogFile = SYS(2023)+ "\" + SYS(2015) + ".txt"
		
			TEXT TO cTmpStr NOSHOW TEXT PRETEXT 14
				"SYS(2801,3)" + CHR(13) +
				"SET EVENTLIST TO MOUSEUP, MOUSEDOWN, keypress"  + CHR(13) +
				"SET EVENTTRACKING TO [<<.cEventLogFile>>]"  + CHR(13) +
				"SET EVENTTRACKING ON"
			ENDTEXT
			cRecOnScript = [EXECSCRIPT(] + cTmpStr + [)]
		
			DO CASE
				CASE .lPlayInsert
					*-- We are inserting from the point where play was paused
					nhWnd = .nTestAppHWnd
				
				CASE .frmMain.pgfmain.Page2.chkNewVFP.Value
					*-- If always to load new VFP instance while recording
					oExternalVFP = CREATEOBJECT("visualfoxpro.application")
					oExternalVFP.Visible=.T.
		
					*-- Reselect the foreground window
					SetForegroundWindow(_screen.hwnd)
					nhWnd = oExternalVFP.hWnd
				OTHERWISE
					nhWnd = .oGlobal.SelApplication(.frmMain.HWnd)
			ENDCASE
		
			lContinue = (m.nhWnd > 0)
		
			IF lContinue
				* Get VFP Session handle
				oAcc = 0
				nRetval = AccessibleObjectFromWindow(m.nhWnd, OBJID_CLIENT, .cguid, @oacc)
				oAccvfp = oacc
		
				IF .frmMain.pgfmain.Page2.chkNewVFP.Value
		      THIS.oVFP = oExternalVFP
		    ELSE
		
		      IF TYPE("oaccvfp.accchild(int(2^31-1))") # "U"
			  		THIS.oVFP = oaccvfp.accchild(int(2^31-1))
		  		ENDIF
		
		    ENDIF
		
				DO CASE
					CASE NOT (TYPE("This.oVFP.Name") # "U" AND This.oVFP.Name = "Microsoft Visual FoxPro")
						*-- If its not VFP application
						MESSAGEBOX(MSG_NONVFP_LOC, WINDOWTITLE_LOC, 16)
						lContinue = .f.
					CASE .oVFP.StartMode > 1
						*-- Runtime libraries
						MESSAGEBOX(MSG_RUNTIME_LOC, WINDOWTITLE_LOC, 16)
						lContinue = .f.
				ENDCASE
		
			ENDIF
		
			lContinue = lContinue AND NOT .lError AND .GetTestInfo()
			IF lContinue
				
				*-- Restore the window if its minimized
				IF .oVFP.Eval("_SCREEN.WindowState") = 1
					.oVFP.DoCmd("_SCREEN.WindowState = 2")
				ENDIF
		
				*-- Store the application co-ordinates so that it can be played back
				*-- relative to the new position
				.nAppLeft = .ovfp.left
				.nAppTop  = .ovfp.top
				.nScreenLeft = .oVFP.Eval("_SCREEN.Left")
				.nScreenTop  = .oVFP.Eval("_SCREEN.Top")
		
				*-- Turn on the event loggin in the AA client
				.oVFP.DoCmd(cRecOnScript)
		
				SetForegroundWindow(nhWnd)
			ENDIF
		
		ENDWITH
		
		RETURN lContinue
	ENDPROC

	PROCEDURE recordend		&& Record end hook
		WITH This
			LOCAL	cRecOffScript, ;
					cCaption, ;
					cPreScript,;
					cTmpStr
					
			LOCAL ARRAY	aTestId[1]
		
			cCaption = .cTestCaption
		
			TEXT TO cTmpStr NOSHOW TEXT PRETEXT 14
				"SET EVENTTRACKING TO"  + CHR(13) +
				"SET EVENTTRACKING OFF" + CHR(13) +
				"SET EVENTLIST TO"
			ENDTEXT
			
			cRecOffScript = [EXECSCRIPT(] + cTmpStr + [)]
		
			cPreScript = ""
		
			*-- Pre script--------------------------begin
			TEXT TO cPreScript NOSHOW
			LPARAMETERS oApp
		
			* Setup Vars
			LOCAL oVFP
			oVFP = oApp.oVFP
		
			* Setup Environment
			oVFP.DoCmd("SYS(2800,16 + 1)")
			ENDTEXT
			*-- Pre script--------------------------end
		
			*-- Reset the AA settings only if the 2nd VFP application is not closed
			IF TYPE("Thisformset.oVFP.Caption") = "C"
				.oVFP.DoCmd(cRecOffScript)
			ENDIF
		
			IF NOT .lPlayInsert
				SELECT aascripts
		
				*-- Unselect all the scripts and select the currently recorded ones
				REPLACE ALL selected WITH .F.
		
				LOCATE FOR UPPER(desc) = UPPER(LEFT(This.cTestName, LEN(desc)))
		
				IF FOUND()
					REPLACE evtlog WITH filetostr(.cEventLogFile), ;
							caption WITH cCaption, ;
							rectime WITH .tRectime
				ELSE
					SELECT MAX(id) FROM aascripts INTO ARRAY aTestId
					aTestid = IIF(EMPTY(aTestId), 1, aTestId + 1)
		
					INSERT INTO aascripts (id, name, desc, evtlog, prescript, postscript, caption, rectime) ;
												VALUES (aTestId, ;
												.cTestName,.cTestName,;
												FILETOSTR(.cEventLogFile), cPreScript, "",;
												cCaption, ;
												.tRectime)
				ENDIF
		
				*-- store the application (_VFP) co-ordinates
				REPLACE AppLeft WITH .nAppLeft, ;
						AppTop  WITH .nAppTop, ;
						ScreenLeft WITH .nScreenLeft, ;
						ScreenTop  WITH .nScreenTop, ;
						selected WITH .T.
			
			ENDIF
		
			*-- Parse the script and update the "script" field
			.ScriptParse()
		
			*-- After parsing we would have fully handled inserting a new recording.
			*-- So go ahead.
			.lPlayInsert = .f.
		
			ERASE (.cEventLogFile)
		ENDWITH
	ENDPROC

	PROCEDURE recordinsscript		&& Insert the recording
		WITH This
			*-- Turn of indication that play was paused
			.lPlayPaused = .f.
			
			*-- Transfer all play paused values to insert values
			.nPlayInsertLine = .nPlayPausedLine
			.nPlayInsertScriptRecno = .nPlayPausedScriptRecno
		
			*-- Turn on play insertion
			.lPlayInsert = .t.
			
			*-- Now start the recording.
			= .Record()
		ENDWITH
		
		RETURN
		
			
			
	ENDPROC

	PROCEDURE recordpause		&& Pause the recording
		LPARAMETERS lPaused
		
		LOCAL cRecPauseScript,cTmpStr 
		
		WITH ThisformSet
		
			*-- If already in Pause, resume recording
			IF lPaused
				TEXT TO cTmpStr NOSHOW TEXT PRETEXT 14
					"SET EVENTTRACKING TO"  + CHR(13) +
					"SET EVENTTRACKING OFF" + CHR(13) +
					"SET EVENTLIST TO"
				ENDTEXT
				cRecPauseScript = [EXECSCRIPT(] + cTmpStr + [)]
				.oVFP.DoCmd(cRecPauseScript)
				.cState = Cc_StateRecordPause
			ELSE
				TEXT TO cTmpStr NOSHOW TEXT PRETEXT 14
					"SET EVENTTRACKING TO [<<.cEventLogFile>>] ADDITIVE"  + CHR(13) +
					"SET EVENTTRACKING ON" + CHR(13) +
					"SET EVENTLIST TO MOUSEUP, MOUSEDOWN, keypress"
				ENDTEXT
				cRecPauseScript = [EXECSCRIPT(] + cTmpStr + [)]
				.oVFP.DoCmd(cRecPauseScript)
				.cState = Cc_StateRecord
			ENDIF
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE recordstop		&& Stop recording and save the script
		WITH This
		
			IF .cState = Cc_StatePlay
				*-- stop playing??
			ELSE
				.RecordEnd()
			ENDIF
		
			.cState = Cc_StateIdle
		
		ENDWITH
		
	ENDPROC

	PROCEDURE scriptparse		&& Parse the event log script
		LOCAL	oPrevEvent, ;
				nParamPosn, ;
				nRightDotPosn, ;
				cParams, ;
				cRest, ;
				cEvent, ;
				cEventId, ;
				nx, ;
				ny, ;
				nCurrTstamp, ;
				lc_TempFile, ;
				ln_Line
		
		WAIT WINDOW MSG_PARSE1_LOC NOWAIT
		
		WITH This
		
			CREATE CURSOR tmpEvents(tstamp n(11,5), fullname c(120), ;
				event c(12), eventid c(8), mx n(6), my n(6), params c(20), rest c(115), foxEvt L)
		
			APPEND FROM (.cEventLogFile) TYPE SDF
		
			SCATTER NAME oPrevEvent BLANK
			
			SCAN
				WAIT WINDOW MSG_PARSE2_LOC + ALLTRIM(STR(RECNO())) + ;
						" of " + ALLTRIM(STR(RECCOUNT())) + "..." NOWAIT
		
				*!*	32273.240, form1.text1.MouseDown(1, 0, 81, 48)
				*!*	32273.380, form1.text1.MouseUp(1, 0, 81, 48)
				*!*	32276.535, KeyPress    00000100 (   1,   30) 65 0 
				*!*	32276.545, form1.KeyPress(97, 0)
				*!*	32276.555, form1.text1.KeyPress(97, 0)
		
				*-- If its VFP events
				IF ATC("MouseUp(", fullname) # 0 OR;
					ATC("MouseDown(", fullname) # 0 OR;
					ATC("KeyPress(", fullname) # 0
					
					*-- If there are screen's mouse/keypress events, ignore (delete) it
					*-- because the windows mouse events also triggered that time...
					IF ATC("screen.", fullname) # 0
						DELETE
						LOOP
					ENDIF
		
					nParamPosn = RAT("(", fullname)
					nRightDotPosn = RAT(".", fullname)
					
					cParams = STRTRAN(SUBSTR(fullname, nParamPosn + 1),")","")  && parameters
					cRest = ALLTRIM(LEFT(fullname, nRightDotPosn - 1)) && rest of event path
					cEvent = SUBSTR(fullname, nRightDotPosn + 1, nParamPosn - nRightDotPosn - 1)
		
					nx = VAL(GETWORDNUM(cParams,3))
					ny = VAL(GETWORDNUM(cParams,4))
					cParams = GETWORDNUM(cParams,1) + " " +  GETWORDNUM(cParams,2)
					cParams = " " + STRTRAN(cParams, ",", " ")  && convert "," to space(1) for consistency
		
					*-- Store athe event id properly like windows events
					*-- in order to use common logic to play back
					DO CASE
						CASE ATC("KeyPress", fullname) # 0
							cEventId = "00000100"
						CASE ATC("MouseDown", fullname) # 0 AND VAL(cParams) = 1
							cEventId = "00000201"
						CASE ATC("MouseUp", fullname) # 0  AND VAL(cParams) = 1
							cEventId = "00000202"
						CASE ATC("MouseDown", fullname) # 0 AND VAL(cParams) = 2
							cEventId = "00000204"
						CASE ATC("MouseUp", fullname) # 0  AND VAL(cParams) = 2
							cEventId = "00000205"
						OTHERWISE
							cEventId = "00000000"
					ENDCASE
					
					*-- If the windows Keypress is succeded by Fox KeyPress, delete the 
					*-- fox keypress event and update the win event with object info.
					IF NOT oPrevEvent.FoxEvt AND ATC("KeyPress", oPrevEvent.event) # 0 AND ;
						ATC("KeyPress(", fullname) # 0
		
						*-- If there are two successive Fox KeyPress followed by
						*-- windows event the control's keypress event will be updated
						*-- against the windows keypress finally...
		
						DELETE
						
						SKIP - 1 && Win keypress
						REPLACE rest	WITH cRest
		
					ELSE
						REPLACE event	WITH cEvent, ;
								eventid	WITH cEventId, ;
								mx		WITH nx, ;
								my		WITH ny, ;
								params	WITH cParams, ;
								rest	WITH cRest, ;
								foxEvt	WITH .t.
					ENDIF
		
				ELSE
				*!*	37280.556, MouseDown   00000201 ( 257,  241) 00000001 formset.form1.edit1.MouseDown
				*!*	37280.707, MouseUp     00000202 ( 257,  241) 00000000 formset.form1.edit1.MouseUp
				*!*	37281.177, KeyPress    00000100 (   1,   30) 65 0 
					cEvent = ALLTRIM(SUBSTR(fullname, 1, 12))
		
					cRest = SUBSTR(fullname, 35)
		
					IF ATC("KeyPress", fullname) # 0
						cParams =  GETWORDNUM(cRest,1) + " " +  GETWORDNUM(cRest,2)
					ELSE
						cParams =  GETWORDNUM(cRest,1) + " "
					ENDIF
					
					cRest = ALLTRIM(STRTRAN(cRest, cParams, ""))
					
					*-- Make sure the event has been removed from the event path
					cRest = STRTRAN(cRest, "." + cEvent, "")
					
					REPLACE event	WITH cEvent, ;
							eventid	WITH SUBSTR(fullname, 13, 8), ;
							mx		WITH VAL(SUBSTR(fullname, 23, 6)), ;
							my		WITH VAL(SUBSTR(fullname, 29, 6)), ;
							params	WITH " " + cParams, ;
							rest	WITH cRest
				ENDIF
				
				SCATTER NAME oPrevEvent
		
			ENDSCAN
		
			WAIT WINDOW MSG_SCRIPTSAVING_LOC NOWAIT
			
			*-- Calculate the delay between events
		
			GO TOP
			oPrevEvent.tstamp = tstamp
		
			SCAN
				nCurrTstamp = tstamp
		
				REPLACE tstamp WITH tstamp - oPrevEvent.tstamp
		
				SCATTER NAME oPrevEvent
				oPrevEvent.tstamp = nCurrTstamp
			ENDSCAN
			*-- Calculate the delay between events - end
		
			COPY FIELDS event, eventid, mx, my, params, rest, tstamp, foxevt TO (.cEventLogFile) SDF
		
			SELECT aascripts
		
			IF NOT .lPlayInsert
				REPLACE SCRIPT WITH FILETOSTR(.cEventLogFile) IN aaScripts
			ELSE
				*-- We were inserting.
				*-- Now merge the new script at the spot
				*-- where the previous script was paused.
				GOTO .nPlayInsertScriptRecno IN aaScripts
		
				lc_TempFile = SYS(2015) + ".tmp"
				
				FOR ln_Line = 1 TO MEMLINES(aaScripts->Script)
				
					= STRTOFILE(MLINE(aaScripts->Script,ln_Line) + Cc_EOL, lc_TempFile, .t.)
					
					IF ln_Line = .nPlayInsertLine
						*-- We got to the line where play was paused
						*-- Now add the new script
						= STRTOFILE(FILETOSTR(.cEventLogFile) + Cc_EOL, lc_TempFile, .t.)
					ENDIF
					
				NEXT
		
				REPLACE SCRIPT WITH FILETOSTR(lc_TempFile) IN aaScripts
			ENDIF
		
		ENDWITH
		
		WAIT CLEAR
		
		USE IN tmpEvents
		
		RETURN
		
	ENDPROC

	PROCEDURE sendmouse
		LPARAMETERS nMouseEvents, x, y
		LOCAL lcInput
		lcInput = CHR(INPUT_MOUSE) + REPLICATE(CHR(0),3)					&& type
		lcInput = lcInput + CHR(m.x%256) + CHR(m.x/256) + REPLICATE(CHR(0),2)	&& dx
		lcInput = lcInput + CHR(m.y%256) + CHR(m.y/256) + REPLICATE(CHR(0),2)	&& dy
		lcInput = lcInput + REPLICATE(CHR(0),4)							&& mouseData
		lcInput = lcInput + CHR(m.nMouseEvents%256) + CHR(m.nMouseEvents/256) + REPLICATE(CHR(0),2)	&& dwFlags
		lcInput = lcInput + REPLICATE(CHR(0),4)				&& time
		lcInput = lcInput + REPLICATE(CHR(0),4)				&& dwExtraInfo
		SendInput(1,lcInput, LEN(lcInput))
		
	ENDPROC

	PROCEDURE str2guid
		LPARAMETERS cstr
		LOCAL i, lcguid
		lcguid = CHR(THIS.hex2val(SUBSTR(m.cstr,7,2))) + CHR(THIS.hex2val(SUBSTR(m.cstr,5,2))) +;
			CHR(THIS.hex2val(SUBSTR(cstr,3,2))) + CHR(THIS.hex2val(SUBSTR(m.cstr,1,2))) +;
			CHR(THIS.hex2val(SUBSTR(cstr,12,2))) + CHR(THIS.hex2val(SUBSTR(m.cstr,10,2))) +;
			CHR(THIS.hex2val(SUBSTR(cstr,17,2))) + CHR(THIS.hex2val(SUBSTR(m.cstr,15,2))) + ;
			CHR(THIS.hex2val(SUBSTR(cstr,20,2))) + CHR(THIS.hex2val(SUBSTR(m.cstr,22,2)))
		FOR i = 0 TO 5
			lcguid = lcguid + CHR(THIS.hex2val(SUBSTR(m.cstr, 25 + m.i * 2, 2)))
		ENDFOR
		RETURN lcguid
		
	ENDPROC

	PROCEDURE str2num
		LPARAMETERS cstr
		local i,n
		n=0
		FOR i = 8 TO 1 STEP -1
			n = m.n * 256 + ASC(SUBSTR(m.cstr,m.i,1))
		ENDFOR
		RETURN n
		
	ENDPROC

	PROCEDURE vieweventlog		&& Veiw event log
		LOCAL cWindow
		
		SELECT aaScripts
		
		*-- If the control is not in a record, search of selected status
		IF EOF("aaScripts")
			LOCATE FOR selected
		ENDIF
		
		*-- If there record is in eof and there is no script selected
		IF EOF("aaScripts")
			MESSAGEBOX(MSG_SELSCRIPT_LOC, 0, WINDOWTITLE_LOC)
		ELSE
			ThisformSet.cState = Cc_StateViewEventLog
		
			DEFINE WINDOW cWindow FROM 5,10 TO 40, 90 ;
				SYSTEM CLOSE GROW FLOAT ZOOM TITLE "Edit Script"
		
			MODIFY MEMO aaScripts.script WINDOW cWindow
		
			ThisformSet.cState = Cc_StateIdle
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.edtStatus.ProgrammaticChange
		WITH This
			*-- Positions mouse cursor on the last line
			*-- This will keep the user informed of the latest status update
			.SelStart = MAX(1, LEN(.Value))
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.edtStatus.Refresh
		LPARAMETERS pl_UpdateIgnore
		
		WITH Thisformset
		
			IF NOT pl_UpdateIgnore
			
				*-- Refresh the status value
				DO CASE
					CASE .cStatePrev = Cc_StatePlay
						*-- Don't reset the value if the previous state is play
					CASE .cState = Cc_StateRecord
						This.Value = MSG_RECORDING1_LOC + CHR(13)
					CASE .cState = Cc_StateRecordPause
						This.Value = MSG_RECORDING2_LOC + CHR(13)
					CASE .cState = Cc_StatePlay
						This.Value = MSG_PLAYBACK1_LOC + CHR(13)
					OTHERWISE
						This.Value = ""
				ENDCASE
				
				IF .cState = Cc_StateIdle
					This.ForeColor = RGB(0,0,0)
				ELSE
					*-- Set to red to show error
					This.ForeColor = RGB(255,0,0)
				ENDIF
		
			ENDIF
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page1.cmdDeleteScript.Click
		= ThisFormSet.DeleteScripts()
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page1.grdscript.UIEnable
		LPARAMETERS lEnable
		
		IF lEnable
			This.Refresh
		ENDIF
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page2.opgdelay.InteractiveChange
		= This.Parent.spnDelay.Refresh()
		
		RETURN
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page2.spndelay.Refresh
		WITH This
		
			IF This.Parent.opgdelay.Value # 1
				.Enabled = .t.
			ELSE
				.Enabled = .f.
				.Value = 0
			ENDIF
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page2.spnRunCount.Init
		THIS.Value = THISFORMSET.nruncount
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page2.spnRunCount.InteractiveChange
		THISFORMSET.nruncount=THIS.Value
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page2.spnRunCount.ProgrammaticChange
		THIS.InteractiveChange()
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page3.cmdDeleteTestLog.Click
		= ThisFormSet.deletetestlog()
		
		RETURN
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page3.grdtestlog.UIEnable
		LPARAMETERS lEnable
		
		IF lEnable
			This.Refresh
		ENDIF
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page4.chkcovelogon.Click
		IF This.Value
			Thisformset.cCoverLogFile = GETFILE("log","","",0,"Coverage Log file")
		ELSE
			Thisformset.cCoverLogFile = ""
		ENDIF
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page4.cmdCovprofiler.Click
		IF NOT EMPTY(_COVERAGE)
		
			IF NOT EMPTY(Thisformset.cCoverLogFile)
				DO (_COVERAGE) WITH (Thisformset.cCoverLogFile)
			ELSE
				DO (_COVERAGE)
			ENDIF
		
		ENDIF
		
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page4.cmdCovprofiler.Init
		This.Enabled = NOT EMPTY(_COVERAGE)
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page4.cmdCovprofiler.Refresh
		This.Enabled = NOT EMPTY(_COVERAGE)
	ENDPROC

	PROCEDURE frmMain.pgfmain.Page4.cmdviewcovlog.Click
		IF NOT EMPTY(Thisformset.cCoverLogFile)
			MODIFY FILE (Thisformset.cCoverLogFile)
		ELSE
			MODIFY FILE GETFILE("log","","",0,"Coverage Log file")
		ENDIF
		
	ENDPROC

	PROCEDURE tbrTest.Activate
		IF TYPE("_SCREEN.ActiveForm.BaseClass") # "C"
			This.Parent.frmMain.Show()
		ENDIF
	ENDPROC

	PROCEDURE tbrTest.chkPause.Click
		WITH This
		
			IF ThisformSet.cState = Cc_StatePlayPause
				.Value = .f.
				ThisFormSet.PlayResume()
			ELSE
				Thisformset.RecordPause(.Value)
			ENDIF
		
		ENDWITH
		
		RETURN
		
			
	ENDPROC

	PROCEDURE tbrTest.chkPause.Refresh
		WITH This
		
			*-- Reset the value because it could have paused and stopped
			IF .Value
				.Value = ThisformSet.cState = Cc_StateRecordPause
			ENDIF
		
			IF INLIST(ThisformSet.cState, Cc_StateRecord, Cc_StateRecordPause, ;
				Cc_StatePlayPause)
				.Enabled = .t.
			ELSE
				.Enabled = .f.
			ENDIF
		
		ENDWITH
		
		RETURN
		
	ENDPROC

	PROCEDURE tbrTest.cmdexit.Click
		Thisformset.Abort
	ENDPROC

	PROCEDURE tbrTest.cmdhelp.Click
		Thisformset.LaunchHelp
	ENDPROC

	PROCEDURE tbrTest.cmdinsscript.Click
		Thisformset.RecordInsScript
		
		RETURN
	ENDPROC

	PROCEDURE tbrTest.cmdinsscript.Refresh
		IF ThisformSet.cState = Cc_StatePlayPause
			This.Enabled = .t.
		ELSE
			This.Enabled = .f.
		ENDIF
		
		RETURN
		
	ENDPROC

	PROCEDURE tbrTest.cmdOpenLog.Click
		Thisformset.ViewEventLog
	ENDPROC

	PROCEDURE tbrTest.cmdOpenLog.Refresh
		IF ThisformSet.cState = Cc_StateIdle
			This.Enabled = .t.
		ELSE
			This.Enabled = .f.
		ENDIF
	ENDPROC

	PROCEDURE tbrTest.cmdplay.Click
		Thisformset.Play
	ENDPROC

	PROCEDURE tbrTest.cmdplay.Refresh
		IF INLIST(ThisformSet.cState, Cc_StateIdle)
			This.Enabled = .t.
		ELSE
			This.Enabled = .f.
		ENDIF	
	ENDPROC

	PROCEDURE tbrTest.cmdrecord.Click
		Thisformset.Record()
		
		RETURN
		
		
	ENDPROC

	PROCEDURE tbrTest.cmdrecord.Refresh
		IF ThisformSet.cState = Cc_StateIdle
			This.Enabled = .t.
		ELSE
			This.Enabled = .f.
		ENDIF
	ENDPROC

	PROCEDURE tbrTest.cmdstop.Click
		IF ThisformSet.cState = Cc_StatePlayPause
			ThisFormSet.PlayStop()
		ELSE
			Thisformset.RecordStop()
		ENDIF
		
		RETURN
		
			
		
	ENDPROC

	PROCEDURE tbrTest.cmdstop.Refresh
		IF INLIST(ThisformSet.cState,  Cc_StatePlay, Cc_StateRecord, Cc_StateRecordPause, ;
			Cc_StatePlayPause)
		
			This.Enabled = .t.
		ELSE
			This.Enabled = .f.
		ENDIF
		
		RETURN
	ENDPROC

	PROCEDURE tbrTest.cmdVFP.Click
		Thisformset.LaunchVFP
	ENDPROC

	PROCEDURE tbrTest.Init
		WITH This
			.Parent.oToolbar = This
		
			*-- Dock at the top
			.Dock(0)
		ENDWITH
	ENDPROC

ENDDEFINE
